x = system_name,
y = total_hazard_analyte,
fill = analyte,
text = paste(
"<b>System:</b>", system_name,
"<br><b>Dominant Analyte:</b>", dominant_analyte,
"<br><b>Contribution:</b>", round(dominant_hazard, 2)
)
)
) +
geom_col(width = 0.7, position = "stack") +
scale_fill_viridis_d(option = "viridis", end = 0.9) +
labs(
title = "Hazard Index Decomposition for Top Systems",
x = "System Name",
y = "Hazard Index",
fill = "Analyte",
caption = "Data source: Michigan PFAS Action Response Team (MPART)"
) +
theme_minimal() +
theme(
axis.text.x = element_text(angle = 45, hjust = 1),
legend.position = "right"
)
# Convert to interactive Plotly chart with automatic hover
ggplotly(p_system_hazard, tooltip = "text") |>
onRender(js_auto_hover) |>
layout(
hoverlabel = list(
bgcolor = "lightyellow",
font = list(color = "black", size = 12),
bordercolor = "orange"
)
)
# Summarize total hazard index per system type
summary_table <- public_water_max_long |>
distinct(system_type, hex_id, Hazard_Index) |>
group_by(system_type) |>
summarise(
total_hazard = sum(Hazard_Index, na.rm = TRUE),
n_sites = n(),
.groups = "drop"
) |>
# Round numeric columns to 2 decimal places
mutate(across(where(is.numeric), ~ round(.x, 2))) |>
arrange(desc(total_hazard))
# Assign a unique ID for reactable
tbl_id <- "system_type_hazard_table"
# Create the interactive table with uppercase headers
rt <- reactable(
summary_table,
elementId = tbl_id,
columns = list(
system_type = colDef(name = "SYSTEM TYPE"),
total_hazard = colDef(name = "TOTAL HAZARD"),
n_sites = colDef(name = "N SITES")
),
searchable = TRUE,
filterable = TRUE,
showPageSizeOptions = TRUE,
defaultPageSize = 10,
highlight = TRUE,
bordered = TRUE,
striped = TRUE
)
# Create download link-style button in top-right
download_btn <- tags$button(
"Download CSV",
onclick = sprintf("Reactable.downloadDataCSV('%s', 'total_hazard_system_type.csv')", tbl_id),
style = "
background: none;
border: none;
color: #0073e6;
text-decoration: underline;
cursor: pointer;
font-size: 0.9em;
float: right;
margin-bottom: 5px;
"
)
# Display table with download link above it
browsable(tagList(download_btn, rt))
# Aggregate hazard contributions by system type
system_analytes_top <- public_water_max_long |>
filter(
Hazard_Index > 1,
!is.na(analyte),
analyte %in% hazard_analytes,
!is.na(system_short)
) |>
mutate(
analyte_hazard = case_when(
analyte == "HFPODA" ~ analyte_value / 10,
analyte == "PFNA"   ~ analyte_value / 10,
analyte == "PFBS"   ~ analyte_value / 2000,
analyte == "PFHxS"  ~ analyte_value / 10
)
) |>
group_by(system_short, analyte) |>
summarise(
total_hazard_analyte = sum(analyte_hazard, na.rm = TRUE),
.groups = "drop"
)
# Compute total hazard per system_short and keep top 15
system_total <- system_analytes_top |>
group_by(system_short) |>
summarise(total_hazard = sum(total_hazard_analyte, na.rm = TRUE), .groups = "drop") |>
arrange(desc(total_hazard)) |>
slice_head(n = 15)
system_analytes_top <- system_analytes_top |>
filter(system_short %in% system_total$system_short) |>
mutate(system_short = factor(system_short, levels = system_total$system_short))
# Compute dominant analyte per system_short for tooltip
dominant_per_system <- system_analytes_top |>
group_by(system_short) |>
slice_max(order_by = total_hazard_analyte, n = 1, with_ties = FALSE) |>
ungroup() |>
rename(dominant_analyte = analyte,
dominant_hazard = total_hazard_analyte) |>
select(system_short, dominant_analyte, dominant_hazard)
# Merge dominant info back
system_analytes_top <- system_analytes_top |>
left_join(dominant_per_system, by = "system_short")
# Create stacked bar plot with tooltip showing only dominant analyte + contribution
p_system_hazard <- ggplot(
system_analytes_top,
aes(
x = system_short,
y = total_hazard_analyte,
fill = analyte,
text = paste(
"<br><b>Dominant Analyte:</b>", dominant_analyte,
"<br><b>Contribution:</b>", round(dominant_hazard, 2)
)
)
) +
geom_col(width = 0.7, position = "stack") +
scale_fill_viridis_d(option = "cividis", end = 0.9) +
labs(
title = "Hazard Index Decomposition for Top System Types",
x = "System Type",
y = "Hazard Index",
fill = "Analyte",
caption = "Data source: Michigan PFAS Action Response Team (MPART)"
) +
theme_minimal() +
theme(
axis.text.x = element_text(angle = 45, hjust = 1),
legend.position = "right"
)
# Convert to interactive Plotly chart with JS auto-hover
ggplotly(p_system_hazard, tooltip = "text") |>
onRender(js_auto_hover) |>
layout(
hoverlabel = list(
bgcolor = "mediumseagreen",
font = list(color = "black", size = 12),
bordercolor = "orange"
)
)
# Filter system_type_table for top systems in the hazard plot
interactive_system_table <- system_type_map |>
filter(short_name %in% system_total$system_short)
tbl_id <- "system_type_table"
# Create interactive table
rt_system <- reactable(
interactive_system_table,
elementId = tbl_id,
searchable = TRUE,
filterable = TRUE,
showPageSizeOptions = TRUE,
defaultPageSize = 10,
highlight = TRUE,
bordered = TRUE,
striped = TRUE,
columns = list(
short_name = colDef(name = "SHORT NAME"),
full_name  = colDef(name = "FULL DESCRIPTIVE NAME")
)
)
# Create download button
download_btn <- tags$button(
"Download CSV",
onclick = sprintf("Reactable.downloadDataCSV('%s', 'system_type_table.csv')", tbl_id),
style = "
background: none;
border: none;
color: #0073e6;
text-decoration: underline;
cursor: pointer;
font-size: 0.9em;
float: right;
margin-bottom: 5px;
"
)
# Display table with download button
browsable(tagList(download_btn, rt_system))
# Filter merged_data for Hazard_Index > 1 and remove NA types
hazard_data <- merged_data |>
filter(Hazard_Index > 1, !is.na(type)) |>
distinct(hex_id, type, Hazard_Index)
# Aggregate mean Hazard_Index and count of sites by site type
mean_by_type <- hazard_data |>
group_by(type) |>
summarise(
mean_hazard = mean(Hazard_Index, na.rm = TRUE),
n_sites = n(),
.groups = "drop"
)
# Order types by mean hazard descending and get top 15
top_types <- mean_by_type |>
arrange(desc(mean_hazard)) |>
slice_head(n = 15)
# Prepare plot data with factor levels for ordering
plot_data <- mean_by_type |>
filter(type %in% top_types$type) |>
mutate(type = factor(type, levels = top_types$type))
# Create ggplot object with tooltip text
p <- ggplot(plot_data, aes(
x = type,
y = mean_hazard,
fill = type,
text = paste("<br><b>Mean Hazard Index:</b>", round(mean_hazard, 2),
"<br><b>Number of Sites:</b>", n_sites)
)) +
geom_col(position = position_dodge(width = 0.7), width = 0.7) +
scale_fill_viridis_d(option = "viridis") +
labs(
title = "Mean Hazard Index by Site Type (Hazard_Index > 1)",
x = "Site Type",
y = "Mean Hazard Index (ppt)",
fill = "Site Type",
caption = "Data source: Michigan PFAS Action Response Team (MPART)"
) +
theme_minimal() +
theme(
legend.position = "right",
axis.text.x = element_text(angle = 45, hjust = 1)
)
# Convert to interactive Plotly object with cycling tooltip
ggplotly(p, tooltip = "text") |>
onRender("
function(el) {
var totalPoints = el.data[0].x.length;
var i = 0;
setInterval(function() {
// Show tooltip for current bar
Plotly.Fx.hover(el, [{ curveNumber: 0, pointNumber: i }], 'xy');
i = (i + 1) % totalPoints;
}, 2000);  // cycle every 2 seconds
}
")
# Visualizing the type of site by the composition of 4 main analytes with the hazard index
# Filter merged_data for Hazard_Index > 1, remove NA types, keep only main analytes
hazard_data <- merged_data |>
filter(Hazard_Index > 1, !is.na(type)) |>
distinct(hex_id, type, analyte, analyte_value, Hazard_Index) |>
filter(analyte %in% hazard_analytes)
# Summarize total hazard and analyte sums by type
hazard_summary_by_type <- hazard_data |>
group_by(type, analyte) |>
summarise(sum_analyte = sum(analyte_value, na.rm = TRUE), .groups = "drop") |>
# Total hazard per type
left_join(
hazard_data |>
group_by(type) |>
summarise(
total_hazard = sum(Hazard_Index, na.rm = TRUE),
n_sites = n_distinct(hex_id),
.groups = "drop"
),
by = "type"
) |>
# Pivot analytes to columns
pivot_wider(
names_from = analyte,
values_from = sum_analyte,
values_fill = 0
) |>
# Round all numeric columns to 2 decimal places
mutate(across(where(is.numeric), ~ round(.x, 2))) |>
arrange(desc(total_hazard))
# Assign a unique ID for reactable
tbl_id <- "hazard_summary_table"
# Create the interactive table with custom headers
rt <- reactable(
hazard_summary_by_type,
elementId = tbl_id,
searchable = TRUE,
filterable = TRUE,
showPageSizeOptions = TRUE,
defaultPageSize = 10,
highlight = TRUE,
bordered = TRUE,
striped = TRUE,
columns = list(
type = colDef(name = "TYPE"),
total_hazard = colDef(name = "TOTAL HAZARD"),
n_sites = colDef(name = "N SITES")
# You can add analyte-specific headers here if needed, e.g.:
# `Lead` = colDef(name = "LEAD"),
# `Arsenic` = colDef(name = "ARSENIC")
)
)
# Create download link-style button in top-right
download_btn <- tags$button(
"Download CSV",
onclick = sprintf("Reactable.downloadDataCSV('%s', 'hazard_summary_by_type.csv')", tbl_id),
style = "
background: none;
border: none;
color: #0073e6;
text-decoration: underline;
cursor: pointer;
font-size: 0.9em;
float: right;
margin-bottom: 5px;
"
)
# Display table with download link above it
browsable(tagList(download_btn, rt))
# Define main hazard analytes
hazard_analytes <- c("HFPODA", "PFNA", "PFBS", "PFHxS")
# Aggregate analyte-level hazard contributions across all hexes
total_analyte_hazard <- public_water_max_long |>
filter(analyte %in% hazard_analytes) |>
mutate(analyte_hazard = case_when(
analyte == "HFPODA" ~ analyte_value / 10,
analyte == "PFNA"   ~ analyte_value / 10,
analyte == "PFBS"   ~ analyte_value / 2000,
analyte == "PFHxS"  ~ analyte_value / 10
)) |>
group_by(analyte) |>
summarise(total_contribution = sum(analyte_hazard, na.rm = TRUE),
.groups = "drop") |>
arrange(desc(total_contribution)) |>
mutate(label = paste0(analyte, " (", round(total_contribution / sum(total_contribution) * 100, 1), "%)"))
# Create pie chart (all slices start un-pulled)
p_pie <- plot_ly(
total_analyte_hazard,
labels = ~label,
values = ~total_contribution,
type = 'pie',
textinfo = 'label',
insidetextorientation = 'radial',
pull = 0,  # initially all slices not pulled
marker = list(line = list(color = '#FFFFFF', width = 1))
) %>%
layout(
title = "Decomposed Hazard Index Contributions by Analyte",
showlegend = FALSE
)
# JS code to pull slices in turns
js_auto_pull <- "
function(el, x) {
var totalSlices = el.data[0].labels.length;
var pulls = Array(totalSlices).fill(0);
var i = 0;
setInterval(function() {
pulls = Array(totalSlices).fill(0);
pulls[i] = 0.15; // pull current slice
Plotly.restyle(el, {'pull': [pulls]});
i = (i + 1) % totalSlices;
}, 2000);
}
"
# Attach JS to pie chart
p_pie <- htmlwidgets::onRender(p_pie, js_auto_pull)
p_pie
# Prepare the metrics table from public_water_max
metrics_table <- public_water_wide |>
select(hex_id, sample_date, Hazard_Index, HFPODAResult, PFNAResult, PFBSResult, PFHxSResult) |>
arrange(desc(Hazard_Index))  # Optional: sort by hazard
# Assign a unique ID for reactable
tbl_id <- "public_water_metrics_table"
# Create the interactive table with uppercase headers
rt <- reactable(
metrics_table,
elementId = tbl_id,
columns = list(
hex_id = colDef(name = "HEX ID"),
sample_date = colDef(name = "SAMPLE DATE"),
Hazard_Index = colDef(name = "HAZARD INDEX"),
HFPODAResult = colDef(name = "HFPO-DA RESULT"),
PFNAResult = colDef(name = "PFNA RESULT"),
PFBSResult = colDef(name = "PFBS RESULT"),
PFHxSResult = colDef(name = "PFHxS RESULT")
),
searchable = TRUE,
filterable = TRUE,
showPageSizeOptions = TRUE,
defaultPageSize = 10,
highlight = TRUE,
bordered = TRUE,
striped = TRUE
)
# Create download link-style button in top-right
download_btn <- tags$button(
"Download CSV",
onclick = sprintf("Reactable.downloadDataCSV('%s', 'public_water_metrics.csv')", tbl_id),
style = "
background: none;
border: none;
color: #0073e6;
text-decoration: underline;
cursor: pointer;
font-size: 0.9em;
float: right;
margin-bottom: 5px;
"
)
# Display table with download link above it
browsable(tagList(download_btn, rt))
# Ensure sample_date is Date
metrics_table <- metrics_table %>%
mutate(sample_date = as.Date(sample_date))
# Pivot to long format for analytes
temporal_long <- metrics_table %>%
pivot_longer(
cols = c(HFPODAResult, PFNAResult, PFBSResult, PFHxSResult),
names_to = "analyte",
values_to = "value"
) %>%
mutate(
analyte = recode(analyte,
"HFPODAResult" = "HFPO-DA",
"PFNAResult" = "PFNA",
"PFBSResult" = "PFBS",
"PFHxSResult" = "PFHxS"),
month = floor_date(sample_date, "month")
)
# Aggregate mean value per month per analyte
temporal_summary <- temporal_long %>%
group_by(month, analyte) %>%
summarise(mean_value = mean(value, na.rm = TRUE), .groups = "drop") %>%
arrange(month)
# Plot temporal trends as line plot
p_temporal_line <- ggplot(
temporal_summary,
aes(
x = month,
y = mean_value,
color = analyte,
group = analyte,
text = paste0("Month: ", month,
"<br>Analyte: ", analyte,
"<br>Mean Value: ", round(mean_value, 2))
)
) +
geom_line(size = 1.2) +
geom_point(size = 2) +
scale_color_viridis_d(option = "cividis") +
labs(
title = "Temporal Trends of PFAS Analytes in Public Water",
x = "Year",
y = "Mean Hazard Contribution",
color = "Analyte"
) +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# Convert to interactive Plotly plot
ggplotly(p_temporal_line, tooltip = "text")
# Prepare metrics table
metrics_table <- public_water_wide |>
select(hex_id, sample_date, Hazard_Index, HFPODAResult, PFNAResult, PFBSResult, PFHxSResult) |>
mutate(sample_date = as.Date(sample_date)) |>
arrange(sample_date)
# Aggregate total hazard by month
hazard_temporal <- metrics_table |>
mutate(month = floor_date(sample_date, unit = "month")) |>
group_by(month) |>
summarise(total_hazard = sum(Hazard_Index, na.rm = TRUE), .groups = "drop")
# Filter 2018-2020
hazard_2018_2020 <- hazard_temporal |> filter(year(month) >= 2018 & year(month) <= 2020)
# Plot
p1 <- ggplot(hazard_2018_2020, aes(x = month, y = total_hazard)) +
geom_line(color = "darkorange", size = 1.2) +
geom_point(aes(text = paste0("Month: ", format(month, "%b %Y"),
"<br>Total Hazard: ", round(total_hazard, 2))),
color = "darkred", size = 2) +
scale_x_date(date_labels = "%Y", date_breaks = "1 year") +
labs(title = "Total Hazard Index: 2018–2020",
x = "Year",
y = "Total Hazard Index") +
theme_minimal()
ggplotly(p1, tooltip = "text")
# Filter 2021-2023
hazard_2021_2023 <- hazard_temporal |> filter(year(month) >= 2021 & year(month) <= 2023)
# Plot
p2 <- ggplot(hazard_2021_2023, aes(x = month, y = total_hazard)) +
geom_line(color = "darkorange", size = 1.2) +
geom_point(aes(text = paste0("Month: ", format(month, "%b %Y"),
"<br>Total Hazard: ", round(total_hazard, 2))),
color = "darkred", size = 2) +
scale_x_date(date_labels = "%Y", date_breaks = "1 year") +
labs(title = "Total Hazard Index: 2021–2023",
x = "Year",
y = "Total Hazard Index") +
theme_minimal()
ggplotly(p2, tooltip = "text")
library(ISLR)
install.packages("ISLR")
library(ISLR)
library(ISLR)
# Auto dataset
data(Auto)
library(ISLR)
library(skimr)
install.packages("skimr")
library(ISLR)
library(skimr)
skim(Auto)
