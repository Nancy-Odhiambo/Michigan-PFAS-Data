text = paste("<br><b>Site Type:</b>",type,
"<br><b>Mean Hazard Index:</b>", round(mean_hazard, 2),
"<br><b>Number of Sites:</b>", n_sites)
)) +
geom_col(position = position_dodge(width = 0.7), width = 0.7) +
scale_fill_viridis_d(option = "cividis") +
labs(
title = "Mean Hazard Index by Site Type (Hazard_Index > 1)",
x = "Site Type",
y = "Mean Hazard Index (ppt)",
fill = "Site Type",
caption = "Data source: Michigan PFAS Action Response Team (MPART)"
) +
theme_minimal() +
theme(
legend.position = "none",
axis.text.x = element_text(angle = 45, hjust = 1)
)
# Convert to interactive Plotly object with cycling tooltip
ggplotly(p, tooltip = "text") |>
onRender("
function(el) {
var totalPoints = el.data[0].x.length;
var i = 0;
setInterval(function() {
// Show tooltip for current bar
Plotly.Fx.hover(el, [{ curveNumber: 0, pointNumber: i }], 'xy');
i = (i + 1) % totalPoints;
}, 2000);  // cycle every 2 seconds
}
")
# Visualizing the type of site by the composition of 4 main analytes with the hazard index
# Filter merged_data for Hazard_Index > 1, remove NA types, keep only main analytes
hazard_data <- merged_data |>
filter(Hazard_Index > 1, !is.na(type)) |>
distinct(hex_id, type, analyte, analyte_value, Hazard_Index) |>
filter(analyte %in% hazard_analytes)
# Summarize total hazard and analyte sums by type
hazard_summary_by_type <- hazard_data |>
group_by(type, analyte) |>
summarise(sum_analyte = sum(analyte_value, na.rm = TRUE), .groups = "drop") |>
# Total hazard per type
left_join(
hazard_data |>
group_by(type) |>
summarise(
total_hazard = sum(Hazard_Index, na.rm = TRUE),
n_sites = n_distinct(hex_id),
.groups = "drop"
),
by = "type"
) |>
# Pivot analytes to columns
pivot_wider(
names_from = analyte,
values_from = sum_analyte,
values_fill = 0
) |>
# Round all numeric columns to 2 decimal places
mutate(across(where(is.numeric), ~ round(.x, 2))) |>
arrange(desc(total_hazard))
# Assign a unique ID for reactable
tbl_id <- "hazard_summary_table"
# Create the interactive table with custom headers
rt <- reactable(
hazard_summary_by_type,
elementId = tbl_id,
searchable = TRUE,
filterable = TRUE,
showPageSizeOptions = TRUE,
defaultPageSize = 10,
highlight = TRUE,
bordered = TRUE,
striped = TRUE,
columns = list(
type = colDef(name = "TYPE"),
total_hazard = colDef(name = "TOTAL HAZARD"),
n_sites = colDef(name = "N SITES")
# You can add analyte-specific headers here if needed, e.g.:
# `Lead` = colDef(name = "LEAD"),
# `Arsenic` = colDef(name = "ARSENIC")
)
)
# Create download link-style button in top-right
download_btn <- tags$button(
"Download CSV",
onclick = sprintf("Reactable.downloadDataCSV('%s', 'hazard_summary_by_type.csv')", tbl_id),
style = "
background: none;
border: none;
color: #0073e6;
text-decoration: underline;
cursor: pointer;
font-size: 0.9em;
float: right;
margin-bottom: 5px;
"
)
# Display table with download link above it
browsable(tagList(download_btn, rt))
merged_data.columns
colnames(merged_data)
# -----------------------------
# 1. Prepare Site Data
# -----------------------------
site_data <- merged_data %>%
filter(!is.na(longitude.y), !is.na(latitude.y)) %>%
select(hex_id, system_name, type, longitude.y, latitude.y) %>%
distinct() %>%
rename(longitude = longitude.y,
latitude = latitude.y)
# Convert to sf (WGS84)
site_sf <- st_as_sf(site_data,
coords = c("longitude", "latitude"),
crs = 4326)
# -----------------------------
# 2. Load Michigan Counties
# -----------------------------
mi_counties <- st_read("GeoFiles/cb_2018_us_county_500k.shp", quiet = TRUE) %>%
filter(STATEFP == "26") %>%
st_transform(4326)   # Fix projection warning (convert to WGS84)
# -----------------------------
# 3. Color Palette for Type
# -----------------------------
type_pal <- colorFactor(
palette = "Set1",
domain = site_sf$type
)
# -----------------------------
# 4. Build Interactive Map
# -----------------------------
leaflet() %>%
# Base map
addProviderTiles(providers$CartoDB.Positron) %>%
# Michigan county boundaries
addPolygons(
data = mi_counties,
fillColor = "transparent",
color = "black",
weight = 1,
opacity = 0.7,
label = ~NAME
) %>%
# Clustered site markers
addCircleMarkers(
data = site_sf,
radius = 6,
fillColor = ~type_pal(type),
color = "black",
weight = 0.5,
fillOpacity = 0.8,
popup = ~paste0(
"<b>System Name:</b> ", system_name, "<br>",
"<b>Type:</b> ", type
),
clusterOptions = markerClusterOptions()
) %>%
# Legend
addLegend(
position = "bottomright",
pal = type_pal,
values = site_sf$type,
title = "Site Type",
opacity = 1
) %>%
# Fit map to Michigan
fitBounds(
lng1 = st_bbox(mi_counties)$xmin,
lat1 = st_bbox(mi_counties)$ymin,
lng2 = st_bbox(mi_counties)$xmax,
lat2 = st_bbox(mi_counties)$ymax
)
library(dplyr)
library(sf)
library(leaflet)
# -----------------------------
# 1. Prepare Site Data
# -----------------------------
site_data <- merged_data %>%
filter(!is.na(longitude.y), !is.na(latitude.y)) %>%
select(hex_id, system_name, type, longitude.y, latitude.y) %>%
distinct() %>%
rename(longitude = longitude.y,
latitude = latitude.y)
site_sf <- st_as_sf(site_data,
coords = c("longitude", "latitude"),
crs = 4326)
# -----------------------------
# 2. Michigan Counties
# -----------------------------
mi_counties <- st_read("GeoFiles/cb_2018_us_county_500k.shp", quiet = TRUE) %>%
filter(STATEFP == "26") %>%
st_transform(4326)
# -----------------------------
# 3. Color Palette
# -----------------------------
type_pal <- colorFactor(
palette = "Set1",
domain = site_sf$type
)
# -----------------------------
# 4. Create Lines Connecting Same Type
# -----------------------------
# Sort by longitude so lines don’t jump randomly
site_lines <- site_sf %>%
arrange(type) %>%
group_by(type) %>%
summarise(do_union = FALSE) %>%
st_cast("LINESTRING")
# -----------------------------
# 5. Build Map
# -----------------------------
leaflet() %>%
addProviderTiles(providers$CartoDB.Positron) %>%
# County boundaries
addPolygons(
data = mi_counties,
fillColor = "transparent",
color = "black",
weight = 1,
opacity = 0.7,
label = ~NAME
) %>%
# Lines connecting same type
addPolylines(
data = site_lines,
color = ~type_pal(type),
weight = 2,
opacity = 0.6
) %>%
# Site markers
addCircleMarkers(
data = site_sf,
radius = 6,
fillColor = ~type_pal(type),
color = "black",
weight = 0.5,
fillOpacity = 0.9,
popup = ~paste0(
"<b>System Name:</b> ", system_name, "<br>",
"<b>Type:</b> ", type
)
) %>%
addLegend(
position = "bottomright",
pal = type_pal,
values = site_sf$type,
title = "Site Type",
opacity = 1
) %>%
fitBounds(
lng1 = st_bbox(mi_counties)$xmin,
lat1 = st_bbox(mi_counties)$ymin,
lng2 = st_bbox(mi_counties)$xmax,
lat2 = st_bbox(mi_counties)$ymax
)
# Filter merged_data for Hazard_Index > 1, remove NA types, keep only main analytes
hazard_data <- merged_data %>%
filter(Hazard_Index > 1, !is.na(type)) %>%
distinct(hex_id, type, analyte, analyte_value, Hazard_Index) %>%
filter(analyte %in% hazard_analytes)
# Summarize total hazard and analyte sums by type
hazard_summary_by_type <- hazard_data %>%
group_by(type, analyte) %>%
summarise(sum_analyte = sum(analyte_value, na.rm = TRUE), .groups = "drop") %>%
# Total hazard per type
left_join(
hazard_data %>%
group_by(type) %>%
summarise(
total_hazard = sum(Hazard_Index, na.rm = TRUE),
n_sites = n_distinct(hex_id),
.groups = "drop"
),
by = "type"
) %>%
# Pivot analytes to columns
pivot_wider(
names_from = analyte,
values_from = sum_analyte,
values_fill = 0
) %>%
# Round numeric columns to 2 decimals
mutate(across(where(is.numeric), ~ round(.x, 2))) %>%
arrange(desc(total_hazard))
# Assign a unique ID for reactable
tbl_id <- "hazard_summary_table"
# Create the interactive reactable table
rt <- reactable(
hazard_summary_by_type,
elementId = tbl_id,
searchable = TRUE,
filterable = TRUE,
showPageSizeOptions = TRUE,
defaultPageSize = 10,
highlight = TRUE,
bordered = TRUE,
striped = TRUE,
columns = list(
type = colDef(name = "TYPE"),
total_hazard = colDef(name = "TOTAL HAZARD"),
n_sites = colDef(name = "N SITES")
# The analytes are already pivoted as columns automatically
)
)
# Create download button above the table
download_btn <- tags$button(
"Download CSV",
onclick = sprintf("Reactable.downloadDataCSV('%s', 'hazard_summary_by_type.csv')", tbl_id),
style = "
background: none;
border: none;
color: #0073e6;
text-decoration: underline;
cursor: pointer;
font-size: 0.9em;
float: right;
margin-bottom: 5px;
"
)
# Display table with download button
browsable(tagList(download_btn, rt))
# Step 1–5: Prepare the system hazard summary table
system_analytes_top <- public_water_max_long %>%
filter(
Hazard_Index > 1,
!is.na(analyte),
analyte %in% hazard_analytes,
!is.na(system_short)
) %>%
mutate(
analyte_hazard = case_when(
analyte == "HFPODA" ~ analyte_value / 10,
analyte == "PFNA"   ~ analyte_value / 10,
analyte == "PFBS"   ~ analyte_value / 2000,
analyte == "PFHxS"  ~ analyte_value / 10
)
) %>%
group_by(system_short, analyte) %>%
summarise(total_hazard_analyte = sum(analyte_hazard, na.rm = TRUE), .groups = "drop")
system_total <- system_analytes_top %>%
group_by(system_short) %>%
summarise(total_hazard = sum(total_hazard_analyte, na.rm = TRUE), .groups = "drop") %>%
arrange(desc(total_hazard)) %>%
slice_head(n = 15)
system_analytes_top <- system_analytes_top %>%
filter(system_short %in% system_total$system_short)
dominant_per_system <- system_analytes_top %>%
group_by(system_short) %>%
slice_max(order_by = total_hazard_analyte, n = 1, with_ties = FALSE) %>%
ungroup() %>%
rename(
dominant_analyte = analyte,
dominant_hazard = total_hazard_analyte
) %>%
select(system_short, dominant_analyte, dominant_hazard)
system_hazard_agg <- system_total %>%
left_join(dominant_per_system, by = "system_short") %>%
left_join(system_type_map %>% select(short_name, full_name),
by = c("system_short" = "short_name")) %>%
mutate(across(where(is.numeric), ~ round(.x, 2))) %>%
arrange(desc(total_hazard))
# Step 6: Create reactable table only (no plot)
tbl_id <- "system_summary_table"
rt_system_summary <- reactable(
system_hazard_agg,
elementId = tbl_id,
searchable = TRUE,
filterable = TRUE,
showPageSizeOptions = TRUE,
defaultPageSize = 10,
highlight = TRUE,
bordered = TRUE,
striped = TRUE,
columns = list(
full_name = colDef(name = "FULL DESCRIPTIVE NAME"),
system_short = colDef(name = "SHORT NAME"),
total_hazard = colDef(name = "TOTAL HAZARD"),
dominant_analyte = colDef(name = "DOMINANT ANALYTE"),
dominant_hazard = colDef(name = "DOMINANT HAZARD")
)
)
# Step 7: Download button
download_btn <- tags$button(
"Download CSV",
onclick = sprintf("Reactable.downloadDataCSV('%s', 'system_summary.csv')", tbl_id),
style = "
background: none;
border: none;
color: #0073e6;
text-decoration: underline;
cursor: pointer;
font-size: 0.9em;
float: right;
margin-bottom: 5px;
"
)
# Display the table with download button
browsable(tagList(download_btn, rt_system_summary))
# Prepare Michigan counties
mi_counties <- st_read("GeoFiles/cb_2018_us_county_500k.shp", quiet = TRUE) %>%
filter(STATEFP == "26") %>%
st_transform(4326)
# Prepare site data
site_sf <- merged_data %>%
filter(!is.na(longitude.y), !is.na(latitude.y)) %>%
select(hex_id, system_name, type, longitude.y, latitude.y) %>%
distinct() %>%
rename(longitude = longitude.y,
latitude = latitude.y) %>%
st_as_sf(coords = c("longitude", "latitude"), crs = 4326) %>%
mutate(
type = str_replace_all(type, "mlitary", "military"),
type = str_to_title(type)
)
# Plot map
ggplot() +
geom_sf(data = mi_counties, fill = "grey90", color = "white") +
geom_sf(data = site_sf, aes(color = type), size = 1.5, alpha = 0.7) +
scale_color_viridis_d() +
labs(
title = "PFAS Sites Across Michigan",
color = "Site Type",
caption = "Data source: Michigan PFAS Action Response Team (MPART), EGLE"
) +
theme_minimal()
library(leaflet)
library(crosstalk)
library(dplyr)
library(sf)
library(htmltools)
library(stringr)
# --- Create SharedData for Crosstalk ---
shared_data <- SharedData$new(site_sf, key = ~hex_id, group = "pfas_map")
# --- Create filter widget (conference-style dropdown) ---
filter_widget <- filter_select(
id = "type_filter",
label = "Select Site Type",
sharedData = shared_data,
group = ~type
)
# --- Create Leaflet map using shared_data ---
map_widget <- shared_data |>
leaflet() |>
setView(lng = -85.5, lat = 44.5, zoom = 6) |>  # roughly Michigan center
addProviderTiles(providers$CartoDB.Positron) |>
# Add Michigan counties
addPolygons(
data = mi_counties,
fillColor = "grey90",
color = "white",
weight = 1,
fillOpacity = 0.5,
label = ~NAME
) |>
# Add site markers
addMarkers(
~st_coordinates(site_sf)[,1],  # longitude
~st_coordinates(site_sf)[,2],  # latitude
popup = ~system_name,
label = ~lapply(system_name, htmltools::HTML),
# optional: colored icons based on type
icon = awesomeIcons(
icon = "circle",
iconColor = "white",
library = "fa",
markerColor = ~case_when(
type == "Military" ~ "red",
type == "Industrial" ~ "blue",
TRUE ~ "green"
)
),
layerId = ~hex_id
) |>
# Add search functionality
addSearchFeatures(
targetGroups = NULL,  # search all markers
options = searchFeaturesOptions(
zoom = 10,
openPopup = TRUE,
firstTipSubmit = TRUE,
autoCollapse = TRUE,
hideMarkerOnCollapse = TRUE,
propertyName = "layerId",
tooltipLimit = -1,
textPlaceholder = "Search for a site..."
)
) |>
# Add filter dropdown as a control
addControl(
htmltools::div(
id = "filter-container",
style = "background: rgba(255,255,255,0.85); padding: 10px; border-radius: 5px;",
filter_widget
),
position = "topright"
) |>
# Prevent map interaction when scrolling over filter
htmlwidgets::onRender("
function(el, x) {
var container = document.getElementById('filter-container');
L.DomEvent.disableScrollPropagation(container);
L.DomEvent.disableClickPropagation(container);
// Center zoom controls at top
var zoomDiv = this.zoomControl.getContainer();
zoomDiv.style.position = 'absolute';
zoomDiv.style.left = '50%';
zoomDiv.style.top = '10px';
zoomDiv.style.transform = 'translateX(-50%)';
}
")
map_widget
