---
title: "Public Water Hazard Index Analysis"
format:
  dashboard:
    orientation: columns  
    theme: flatly            
    toc: true              
    self-contained: true   
execute:
  echo: false
  warning: false
  message: false
  output: true
---

```{r}
#| include: false
set.seed(1994)

# Loading necessary packages
library(tidyverse)
library(naniar)
library(janitor)
library(sf)
library(gt)
library(skimr)
library(tidycensus)
library(maps)
library(patchwork)
library(ggrepel)
library(ggthemes)
library(scales)
library(reshape2)
library(ggcorrplot)
library(flextable)
library(dplyr)
library(tidyr)
library(plotly)
library(leaflet)
library(reactable)
library(reactablefmtr)
library(htmltools)
library(leaflet.extras2)
library(leaflegend)
library(htmlwidgets)
library(leaflet.extras)
library(crosstalk)



# Function for creating data dictionary
data_dictionary <- function(myData, descripts) {
tibble(Variable = colnames(myData),
       Type = map_chr(myData, .f = function(x){typeof(x)[1]}),
       Description = descripts) |> 
  gt()
}
```

```{r PFAS_packages}
#| eval: true
#| include: false

# Create function to add geoid variable given longitude and latitude for county-level data
add_geoid <- function(my_data) {
  # Create sf object to help add geoid column
my_data_sf <- my_data |> 
st_as_sf(coords = c("longitude", "latitude"))

# Set coordinate reference system (CRS) to match counties data
counties <- st_read("GeoFiles//cb_2018_us_county_500k.shp")
st_crs(my_data_sf) <- st_crs(counties)

ret_data <- my_data_sf |> 
  st_join(counties) |> 
    mutate(longitude = st_coordinates(geometry)[, 1],
           latitude = st_coordinates(geometry)[, 2]) |> 
  st_drop_geometry() |> 
  as_tibble() |> 
  dplyr::select(GEOID, longitude, latitude) |> 
  dplyr::rename(geoid = GEOID) |> 
  distinct() |> 
  right_join(my_data)

return(ret_data)
}
```


```{r PFAS_surface_clean}
#| eval: true
#| include: false

# Importing data on PFAS levels in surface water in Michigan
analyte_info <- read_csv("PFAS_Surface_Water_Sampling.csv") |> 
              dplyr::select(-c(X:Latitude, GlobalID, OBJECTID,
                               ends_with("Flag")))

surface_water <- read_csv("PFAS_Surface_Water_Sampling.csv") |> 
  clean_names() |> 
  dplyr::select(-ends_with("_flag")) |> 
  dplyr::select(-c(cas307244_pf_hx_a:cas919005144_adona_rl)) |> 
  bind_cols(analyte_info)

# Importing data on surface water data dictionary
surface_water_dictionary <- read_csv("surface_water_data_dictionary.csv")

# Creating long version of surface water data
surface_water_long <- surface_water |> 
  dplyr::rename(object_id = objectid) |> 
  dplyr::select(longitude, latitude, object_id, everything(), 
                -c(x:y), -ends_with("Flag"), -global_id) |> 
  pivot_longer(cols = colnames(analyte_info), 
               names_to = "analyte", 
               values_to = "analyte_value") |> 
  dplyr::select(-matrix, -unit, -object_id) |> 
  add_geoid()

# Saving to external CSV
write_csv(surface_water_long, file = "pfas_surface_water_long.csv")
```


```{r PFAS_public_clean}
#| eval: true
#| include: false

# Importing shape file data for public water supply PFAS levels data
public_water_shape <- st_read("Public_Water_Supply_Sampling_Hexbins_and_Results/Public_Water_Supply_Sampling_Hexbins.shp") |> 
  mutate(centroid = st_centroid(geometry),
         longitude = st_coordinates(centroid)[, 1],
         latitude = st_coordinates(centroid)[, 2]) |> 
  dplyr::select(HexID, longitude, latitude) |> 
  st_drop_geometry() |> 
  as_tibble()

# Importing data on public water supply PFAS levels
public_water <- read_csv("Public_Water_Supply_Sampling_Hexbins_and_Results.csv")

# Adding geoid, longitude, and latitude information to public water data
# and cleaning variable names
public_water_wide <- public_water |> 
  left_join(public_water_shape, by = "HexID") |> 
  dplyr::select(-ends_with(c("Result", "Flags"))) |> 
  clean_names() |> 
  dplyr::rename(object_id = objectid) |> 
  dplyr::select(object_id:sys_loc_code, longitude, latitude, everything()) |> 
  bind_cols(dplyr::select(public_water, ends_with("Result"))) |> 
  add_geoid()

# Pivoting public water data from wide to long format
public_water_long <- public_water_wide |> 
  pivot_longer(cols = c(ends_with(c("Result"))), 
               names_to = "analyte", 
               values_to = "analyte_value") |> 
  mutate(analyte = gsub(analyte, pattern = "Result", replacement = "")) |> 
  dplyr::select(-c(hex_id, 
                   wssn, loc_name:sys_loc_code, 
                   phase_code:task_type,
                   treatment_status:sys_sample_code,
                   lab_number:lab_sdg, 
                   object_id, position_source,
                   analytical_method,
                   sampling_results_count)) |> 
  mutate(system_type = fct_recode(system_type,
                               "Non-Community Water Supply (Adult Foster Care Provider)" = "ADFSTC",
                               "Non-Community Water Supply (Children's Camp)" = "CHLCMP",
                               "Non-Community Water Supply (Child Care Provider)" = "DAYCARE",
                               "Non-Community Water Supply (Industry)" = "INDUS",
                               "Non-Community Water Supply (Medical Care Provider)" = "MEDCAR",
                               "Non-Community Water Supply (Hotel or Motel)" = "MOTEL",
                               "Community Water Supply (for example Municipal Supply, Apartment, Nursing Home, Prison, etc.)" = "MUN",
                               "Office Building" = "OFFICE",
                               "Park" = "PARK",
                               "Residential" = "RESD",
                               "School" = "SCH",
                               "Tribal Lands" = "TRB"))


# Saving to external CSV
write_csv(public_water_long, file = "pfas_public_water_long.csv")
```


```{r PFAS_sites_import}
#| eval: true
#| include: false

pfas_site_path <- "pfas_sites.csv"

if(file.exists(pfas_site_path) == FALSE) {
# Importing data on identified sites from https://www.michigan.gov/pfasresponse
# Downloaded on 02/25/2025
pfas_sites <- read_csv("Michigan_PFAS_Sites.csv") |> 
  janitor::clean_names() |> 
  dplyr::select(facility:site_type, location:military, facility_date, site_background:anticipated_activities, -tier, -site_type) |> 
  add_geoid()

# Saving cleaned data
write_csv(pfas_sites, file = pfas_site_path)
} else {
  # Importing
  pfas_sites <- read_csv(pfas_site_path)
}
```

```{r}
# Drop flag columns, replace NA in PFAS Result columns with 0, and ensure numeric
public_water_wide <- public_water_wide |> 
  select(-ends_with("Flags")) |> 
  mutate(across(ends_with("Result"), ~replace_na(as.numeric(.x), 0)))

# Calculating the hazard index
public_water_wide <- public_water_wide |>
  mutate(Hazard_Index = (HFPODAResult / 10) +
         (PFNAResult / 10) +
         (PFBSResult / 2000) +
         (PFHxSResult / 10))
```


```{r}
# Displaying the high index areas with the highest analyte contributor in a table
high_hazard <- public_water_wide |> 
  filter(Hazard_Index > 1) |> 
  select(hex_id, sample_date, Hazard_Index, HFPODAResult, PFNAResult, PFBSResult, PFHxSResult) |> 
  arrange(desc(Hazard_Index)) |> 
  flextable() |> 
  set_caption("Public Water Locations with Hazard Index > 1") |> 
  autofit()
```

```{r}
# Extracting the maximum hazard per hex ID
public_water_max <- public_water_wide |> 
  group_by(hex_id) |> 
  slice_max(order_by = Hazard_Index, n = 1, with_ties = FALSE) |> 
  ungroup()
```


```{r}
# Changing the wide format to long format
public_water_max_long <- public_water_max |>
pivot_longer(cols = ends_with("Result"),   
               names_to = "analyte",
               values_to = "analyte_value") |>
mutate(analyte = gsub("Result$", "", analyte))
```


```{r}
merged_data <- public_water_max_long |>
  left_join(
    pfas_sites |> mutate(geoid = as.character(geoid)), 
    by = "geoid",
    relationship = "many-to-many"
  )
```

```{r}
# Reusable JS for auto-hover
js_auto_hover <- "
function(el, x) {
  var totalPoints = el.data[0].x.length;
  var i = 0;
  setInterval(function() {
    Plotly.Fx.hover(el, [{ curveNumber: 0, pointNumber: i }]);
    i = (i + 1) % totalPoints;
  }, 2000);
}
"
```

```{r}
# Reusable JS for auto-hover on pie charts
js_auto_hover_pie <- "
function(el, x) {
  var totalSlices = el.data[0].labels.length; // number of pie slices
  var i = 0;
  setInterval(function() {
    Plotly.Fx.hover(el, [{ curveNumber: 0, pointNumber: i }]);
    i = (i + 1) % totalSlices;
  }, 2000);
}
"
```

```{r}
# Prepare system type mapping
system_type_map <- tibble(
  short_name = c(
    "ADFSTC", "CHLCMP", "DAYCARE", "INDUS", "MEDCAR",
    "MOTEL", "MUN", "OFFICE", "PARK", "RESD", "SCH", "TRB"
  ),
  full_name = c(
    "Non-Community Water Supply (Adult Foster Care Provider)",
    "Non-Community Water Supply (Children's Camp)",
    "Non-Community Water Supply (Child Care Provider)",
    "Non-Community Water Supply (Industry)",
    "Non-Community Water Supply (Medical Care Provider)",
    "Non-Community Water Supply (Hotel or Motel)",
    "Community Water Supply (for example Municipal Supply, Apartment, Nursing Home, Prison, etc.)",
    "Office Building",
    "Park",
    "Residential",
    "School",
    "Tribal Lands"
  )
)

# Apply short names to the dataset
public_water_max_long <- public_water_max_long |>
  mutate(system_short = recode(system_type,
    "Non-Community Water Supply (Adult Foster Care Provider)" = "ADFSTC",
    "Non-Community Water Supply (Children's Camp)" = "CHLCMP",
    "Non-Community Water Supply (Child Care Provider)" = "DAYCARE",
    "Non-Community Water Supply (Industry)" = "INDUS",
    "Non-Community Water Supply (Medical Care Provider)" = "MEDCAR",
    "Non-Community Water Supply (Hotel or Motel)" = "MOTEL",
    "Community Water Supply (for example Municipal Supply, Apartment, Nursing Home, Prison, etc.)" = "MUN",
    "Office Building" = "OFFICE",
    "Park" = "PARK",
    "Residential" = "RESD",
    "School" = "SCH",
    "Tribal Lands" = "TRB"
  ))
```

## Hazard Index Analysis {.tabset}

### Total Hazard Composition
#### Analyte Composition
```{r}
# Define main hazard analytes
hazard_analytes <- c("HFPODA", "PFNA", "PFBS", "PFHxS")

# Aggregate analyte-level hazard contributions across all hexes
total_analyte_hazard <- public_water_max_long |>
  filter(analyte %in% hazard_analytes) |>           
  mutate(analyte_hazard = case_when(
    analyte == "HFPODA" ~ analyte_value / 10,
    analyte == "PFNA"   ~ analyte_value / 10,
    analyte == "PFBS"   ~ analyte_value / 2000,
    analyte == "PFHxS"  ~ analyte_value / 10
  )) |>
  group_by(analyte) |>
  summarise(
    total_contribution = sum(analyte_hazard, na.rm = TRUE),
    .groups = "drop"
  ) |>
  arrange(desc(total_contribution)) |>
  mutate(
    percent = round(total_contribution / sum(total_contribution) * 100, 1),
    analyte = factor(analyte, levels = analyte)
  )

# JS for automatic hover (consistent with your other plots)
js_auto_hover <- "
function(el, x) {
  var totalBars = el.data[0].x.length;
  var i = 0;
  setInterval(function() {
    Plotly.Fx.hover(el, [{ curveNumber: 0, pointNumber: i }], 'xy');
    i = (i + 1) % totalBars;
  }, 2000);
}
"

# Extend y-axis to prevent clipped text
y_max <- max(total_analyte_hazard$total_contribution, na.rm = TRUE) * 1.15

# Create Plotly bar chart with cividis palette
p_bar <- plot_ly(
  data = total_analyte_hazard,
  x = ~analyte,
  y = ~total_contribution,
  type = "bar",
  color = ~analyte,
  colors = viridis::viridis(
    n = length(unique(total_analyte_hazard$analyte)),
    option = "cividis"
  ),
  text = ~paste0(percent, "%"),
  textposition = "outside",
  hoverinfo = "text",
  hovertext = ~paste(
    "<b>Analyte:</b>", analyte,
    "<br><b>Total Contribution:</b>", round(total_contribution, 2),
    "<br><b>Percent of Total:</b>", percent, "%"
  )
) |>
  layout(
    title = "Total Decomposed Hazard Index Contributions by Analyte",
    xaxis = list(title = "Analyte"),
    yaxis = list(
      title = "Total Hazard Index Contribution",
      range = c(0, y_max)
    ),
    showlegend = FALSE,
    margin = list(t = 80),
    hoverlabel = list(
      bgcolor = "lightyellow",
      font = list(color = "black", size = 12),
      bordercolor = "orange"
    )
  ) |>
  onRender(js_auto_hover)

p_bar
```

```{r}
# Prepare the metrics table from public_water_max
metrics_table <- public_water_wide |>
  select(hex_id, sample_date, Hazard_Index, HFPODAResult, PFNAResult, PFBSResult, PFHxSResult) |>
  arrange(desc(Hazard_Index))  # Optional: sort by hazard

# Assign a unique ID for reactable
tbl_id <- "public_water_metrics_table"

# Create the interactive table with uppercase headers
rt <- reactable(
  metrics_table,
  elementId = tbl_id,
  columns = list(
    hex_id = colDef(name = "HEX ID"),
    sample_date = colDef(name = "SAMPLE DATE"),
    Hazard_Index = colDef(name = "HAZARD INDEX"),
    HFPODAResult = colDef(name = "HFPO-DA RESULT"),
    PFNAResult = colDef(name = "PFNA RESULT"),
    PFBSResult = colDef(name = "PFBS RESULT"),
    PFHxSResult = colDef(name = "PFHxS RESULT")
  ),
  searchable = TRUE,
  filterable = TRUE,
  showPageSizeOptions = TRUE,
  defaultPageSize = 10,
  highlight = TRUE,
  bordered = TRUE,
  striped = TRUE
)

# Create download link-style button in top-right
download_btn <- tags$button(
  "Download CSV",
  onclick = sprintf("Reactable.downloadDataCSV('%s', 'public_water_metrics.csv')", tbl_id),
  style = "
    background: none;
    border: none;
    color: #0073e6;
    text-decoration: underline;
    cursor: pointer;
    font-size: 0.9em;
    float: right;
    margin-bottom: 5px;
  "
)

# Display table with download link above it
browsable(tagList(download_btn, rt))
```

### Maps
#### Michigan PFAS Map
```{r}
# Define main hazard analytes
hazard_analytes <- c("HFPODA", "PFNA", "PFBS", "PFHxS")

# Load Michigan counties shapefile
mi_counties <- st_read("GeoFiles/cb_2018_us_county_500k.shp", quiet = TRUE) %>%
  filter(STATEFP == "26")

# Prepare analyte-wide data
analyte_wide <- public_water_max_long %>%
  filter(analyte %in% hazard_analytes) %>%
  select(hex_id, analyte, analyte_value) %>%
  pivot_wider(
    names_from = analyte,
    values_from = analyte_value,
    values_fill = 0
  )

# Prepare hazard sites
hazard_sites_full <- public_water_max_long %>%
  filter(Hazard_Index > 1) %>%
  distinct(hex_id, system_name, system_type, Hazard_Index, longitude, latitude) %>%
  rename(type = system_type) %>%
  left_join(analyte_wide, by = "hex_id") %>%
  st_as_sf(coords = c("longitude", "latitude"), crs = 4326) %>%
  mutate(Hazard_Index = as.numeric(Hazard_Index))

# Color palette
max_radius <- 20
hazard_pal <- colorNumeric(
  palette = "YlOrRd",
  domain = c(0, max(hazard_sites_full$Hazard_Index, na.rm = TRUE))
)

hazard_sites_full <- hazard_sites_full %>%
  mutate(scaled_radius = sqrt(Hazard_Index / max(Hazard_Index, na.rm = TRUE)) * max_radius)

# Popups
hazard_popup <- hazard_sites_full %>%
  mutate(popup = paste0(
    "<b>System Name:</b> ", system_name, "<br>",
    "<b>Type:</b> ", type, "<br>",
    "<b>Hazard Index:</b> ", round(Hazard_Index, 2), "<br>",
    "<b>HFPODA:</b> ", round(HFPODA, 2), "<br>",
    "<b>PFNA:</b> ", round(PFNA, 2), "<br>",
    "<b>PFBS:</b> ", round(PFBS, 2), "<br>",
    "<b>PFHxS:</b> ", round(PFHxS, 2)
  ))

# Legend values (just 3 representative bubbles)
legend_values <- c(0.25, 0.5, 1)  # fraction of max for size
legend_radius <- sqrt(legend_values) * max_radius
legend_colors <- hazard_pal(legend_values * max(hazard_sites_full$Hazard_Index, na.rm = TRUE))

# Build custom HTML legend (color + size only, horizontal layout)
legend_html <- paste0(
  "<div style='line-height:1.5;background:white;padding:10px;border-radius:5px;
                      box-shadow:0 0 5px rgba(0,0,0,0.3);width:auto;'>",
  "<h4 style='margin:0;color:#4B0082;'>Hazard Index</h4>",
  "<div style='display:flex;align-items:center;justify-content:space-around;'>",
  paste0(
    sapply(seq_along(legend_values), function(i) {
      paste0(
        "<svg height='", max(legend_radius)*2, "' width='", max(legend_radius)*2, "' style='margin-right:5px;'>",
        "<circle cx='", max(legend_radius), "' cy='", max(legend_radius),
        "' r='", legend_radius[i], "' fill='", legend_colors[i],
        "' fill-opacity='0.7' stroke='black' stroke-width='0.5'/>",
        "</svg>"
      )
    }),
    collapse = ""
  ),
  "</div>",
  "</div>"
)

# Get bounding box of Michigan counties
mi_bounds <- st_bbox(mi_counties)

# Build interactive Leaflet map with custom zoom and bubble legend
leaflet(hazard_sites_full) %>%
  # Center on Michigan with zoomed-out view so full state fits
  setView(lng = -84.5, lat = 44.5, zoom = 6) %>%
  
  # Base map tiles
  addProviderTiles(providers$CartoDB.Positron) %>%
  
  # Michigan county polygons
  addPolygons(
    data = mi_counties,
    fillColor = "grey",
    color = "black",
    weight = 1,
    fillOpacity = 0.3,
    label = ~NAME
  ) %>%
  
  # Hazard site markers
  addCircleMarkers(
    radius = ~scaled_radius,  # proportional to Hazard_Index
    fillColor = ~hazard_pal(Hazard_Index),
    color = "black",
    fillOpacity = 0.7,
    stroke = TRUE,
    weight = 0.5,
    label = lapply(hazard_popup$popup, HTML),
    labelOptions = labelOptions(
      direction = "auto",
      textsize = "12px",
      opacity = 0.9,
      offset = c(0, -5)
    )
  ) %>%
  
  # Custom HTML bubble legend (color + size only)
  addControl(html = legend_html, position = "topright")

```

```{r}

# Define main hazard analytes
hazard_analytes <- c("HFPODA", "PFNA", "PFBS", "PFHxS")

# Load Michigan counties shapefile
mi_counties <- st_read("GeoFiles/cb_2018_us_county_500k.shp", quiet = TRUE) %>%
  filter(STATEFP == "26")

# Prepare analyte-wide data
analyte_wide <- public_water_max_long %>%
  filter(analyte %in% hazard_analytes) %>%
  select(hex_id, analyte, analyte_value) %>%
  pivot_wider(
    names_from = analyte,
    values_from = analyte_value,
    values_fill = 0
  )

# Prepare hazard sites with Hazard_Index > 1
hazard_sites_full <- public_water_max_long %>%
  filter(Hazard_Index > 1) %>%
  distinct(hex_id, system_name, system_type, Hazard_Index, longitude, latitude) %>%
  left_join(analyte_wide, by = "hex_id") %>%
  st_as_sf(coords = c("longitude", "latitude"), crs = 4326) %>%
  mutate(Hazard_Index = as.numeric(Hazard_Index))

# Define color palette and radius scaling
max_radius <- 20
hazard_pal <- colorNumeric(
  palette = "YlOrRd",
  domain = c(0, max(hazard_sites_full$Hazard_Index, na.rm = TRUE))
)
hazard_sites_full <- hazard_sites_full %>%
  mutate(scaled_radius = sqrt(Hazard_Index / max(Hazard_Index, na.rm = TRUE)) * max_radius)

# Create popups
hazard_popup <- hazard_sites_full %>%
  mutate(popup = paste0(
    "<b>System Name:</b> ", system_name, "<br>",
    "<b>Type:</b> ", system_type, "<br>",
    "<b>Hazard Index:</b> ", round(Hazard_Index, 2), "<br>",
    "<b>HFPODA:</b> ", round(HFPODA, 2), "<br>",
    "<b>PFNA:</b> ", round(PFNA, 2), "<br>",
    "<b>PFBS:</b> ", round(PFBS, 2), "<br>",
    "<b>PFHxS:</b> ", round(PFHxS, 2)
  ))

# Custom HTML legend
legend_values <- c(0.25, 0.5, 0.75, 1)
legend_radius <- sqrt(legend_values) * max_radius
legend_colors <- hazard_pal(legend_values * max(hazard_sites_full$Hazard_Index, na.rm = TRUE))
legend_html <- paste0(
  "<div style='line-height:1.5;background:white;padding:10px;border-radius:5px;
                      box-shadow:0 0 5px rgba(0,0,0,0.3);width:auto;'>",
  "<h4 style='margin:0;color:#4B0082;'>Hazard Index</h4>",
  "<div style='display:flex;align-items:center;justify-content:space-around;'>",
  paste0(
    sapply(seq_along(legend_values), function(i) {
      paste0(
        "<svg height='", max(legend_radius)*2, "' width='", max(legend_radius)*2, "' style='margin-right:5px;'>",
        "<circle cx='", max(legend_radius), "' cy='", max(legend_radius),
        "' r='", legend_radius[i], "' fill='", legend_colors[i],
        "' fill-opacity='0.7' stroke='black' stroke-width='0.5'/>",
        "</svg>"
      )
    }),
    collapse = ""
  ),
  "</div>",
  "</div>"
)

# Wrap hazard sites in SharedData for filtering
shared_sites <- SharedData$new(hazard_sites_full)

```


### County Analysis
#### Top 15 Hazard > 1

```{r}
# JS for automatic bar hover
js_auto_hover <- "
function(el, x) {
  var totalPoints = el.data[0].y.length;
  var i = 0;
  setInterval(function() {
    Plotly.Fx.hover(el, [{ curveNumber: 0, pointNumber: i }], 'xy');
    i = (i + 1) % totalPoints;
  }, 2000);
}
"

# Define main hazard analytes
hazard_analytes <- c("HFPODA", "PFNA", "PFBS", "PFHxS")

# Aggregate analyte-level hazard contributions per county
county_analytes <- public_water_max_long %>%
  filter(
    Hazard_Index > 1,
    analyte %in% hazard_analytes,
    !is.na(analyte_value)
  ) %>%
  mutate(
    analyte_hazard = case_when(
      analyte == "HFPODA" ~ analyte_value / 10,
      analyte == "PFNA"   ~ analyte_value / 10,
      analyte == "PFBS"   ~ analyte_value / 2000,
      analyte == "PFHxS"  ~ analyte_value / 10
    )
  ) %>%
  group_by(geoid, analyte) %>%
  summarise(
    total_hazard_analyte = sum(analyte_hazard, na.rm = TRUE),
    n_sites = n_distinct(system_name),
    .groups = "drop"
  )

# Join county names and remove unknown counties
county_info <- st_read("GeoFiles/cb_2018_us_county_500k.shp", quiet = TRUE) %>%
  st_drop_geometry() %>%
  select(GEOID, NAME)

county_analytes <- county_analytes %>%
  left_join(county_info, by = c("geoid" = "GEOID")) %>%
  filter(!is.na(NAME))

# Compute total hazard per county to get top 15
county_total <- county_analytes %>%
  group_by(NAME) %>%
  summarise(
    total_hazard = sum(total_hazard_analyte, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  arrange(desc(total_hazard)) %>%
  slice_head(n = 15)

# Identify dominant analyte per county for tooltip
dominant_per_county <- county_analytes %>%
  filter(NAME %in% county_total$NAME) %>%
  group_by(NAME) %>%
  slice_max(total_hazard_analyte, n = 1, with_ties = FALSE) %>%
  ungroup() %>%
  select(NAME, dominant_analyte = analyte, dominant_hazard = total_hazard_analyte)

# Prepare plot data: top 15 counties only, ordered by total hazard
plot_data <- county_analytes %>%
  filter(NAME %in% county_total$NAME) %>%
  left_join(dominant_per_county, by = "NAME") %>%
  left_join(county_total, by = "NAME") %>%
  arrange(desc(total_hazard)) %>%
  mutate(NAME = factor(NAME, levels = unique(NAME)))  # enforce descending order

# Create Plotly stacked bar chart
p_overall <- plot_ly(
  data = plot_data,
  x = ~NAME,
  y = ~total_hazard_analyte,
  type = "bar",
  color = ~analyte,
  colors = viridis::cividis(length(hazard_analytes), end = 0.9),
  hoverinfo = "text",
  text = ~round(total_hazard_analyte, 2),
  textposition = "inside",
  hovertext = ~paste0(
    "<b>County:</b> ", NAME,
    "<br><b>Total Hazard Index:</b> ", round(total_hazard, 2),
    "<br><b>Dominant Analyte:</b> ", dominant_analyte,
    "<br><b>Contribution of Dominant Analyte:</b> ", round(dominant_hazard, 2),
    "<br><b>Number of Sites:</b> ", n_sites
  )
) %>%
  layout(
    title = "Top 15 Counties with Hazard Index >1",
    barmode = "stack",
    xaxis = list(title = "County", tickangle = -45),
    yaxis = list(title = "Hazard Index"),
    margin = list(b = 150),
    hoverlabel = list(
      bgcolor = "lightyellow",
      font = list(size = 12, color = "black"),
      bordercolor = "orange"
    )
  ) %>%
  onRender(js_auto_hover)

p_overall

```
```{r}
# JS for automatic bar hover
js_auto_hover <- "
function(el, x) {
  var totalPoints = el.data[0].y.length;
  var i = 0;
  setInterval(function() {
    Plotly.Fx.hover(el, [{ curveNumber: 0, pointNumber: i }], 'xy');
    i = (i + 1) % totalPoints;
  }, 2000);
}
"

# Define main hazard analytes
hazard_analytes <- c("HFPODA", "PFNA", "PFBS", "PFHxS")

# Aggregate analyte-level hazard contributions per county
county_analytes <- public_water_max_long %>%
  filter(
    Hazard_Index > 1,
    analyte %in% hazard_analytes,
    !is.na(analyte_value)
  ) %>%
  mutate(
    analyte_hazard = case_when(
      analyte == "HFPODA" ~ analyte_value / 10,
      analyte == "PFNA"   ~ analyte_value / 10,
      analyte == "PFBS"   ~ analyte_value / 2000,
      analyte == "PFHxS"  ~ analyte_value / 10
    )
  ) %>%
  group_by(geoid, analyte) %>%
  summarise(
    total_hazard_analyte = sum(analyte_hazard, na.rm = TRUE),
    n_sites = n_distinct(system_name),
    .groups = "drop"
  )

# Join county names
county_info <- st_read("GeoFiles/cb_2018_us_county_500k.shp", quiet = TRUE) %>%
  st_drop_geometry() %>%
  select(GEOID, NAME)

county_analytes <- county_analytes %>%
  left_join(county_info, by = c("geoid" = "GEOID")) %>%
  filter(!is.na(NAME))

# Compute total hazard per county to get top 15
county_total <- county_analytes %>%
  group_by(NAME) %>%
  summarise(
    total_hazard = sum(total_hazard_analyte, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  arrange(desc(total_hazard)) %>%
  slice_head(n = 15)

# Compute % contribution per analyte and prepare hover text
plot_data <- county_analytes %>%
  filter(NAME %in% county_total$NAME) %>%
  left_join(county_total, by = "NAME") %>%
  group_by(NAME) %>%
  mutate(
    percent_hazard = 100 * total_hazard_analyte / total_hazard
  ) %>%
  ungroup() %>%
  arrange(desc(total_hazard)) %>%
  mutate(NAME = factor(NAME, levels = unique(NAME)))

# Compute dominant analyte per county
dominant_per_county <- plot_data %>%
  group_by(NAME) %>%
  slice_max(total_hazard_analyte, n = 1, with_ties = FALSE) %>%
  ungroup() %>%
  select(NAME, dominant_analyte = analyte, dominant_hazard = total_hazard_analyte)

# Hover text per county: only non-zero analytes
hover_text_per_county <- plot_data %>%
  filter(percent_hazard > 0) %>%
  group_by(NAME) %>%
  summarise(
    hover_text = paste0(analyte, ": ", round(percent_hazard, 1), "%", collapse = "<br>"),
    .groups = "drop"
  )

# Join dominant analyte and hover text
plot_data <- plot_data %>%
  left_join(dominant_per_county, by = "NAME") %>%
  left_join(hover_text_per_county, by = "NAME")

# Create Plotly stacked bar chart
p_overall <- plot_ly(
  data = plot_data,
  x = ~NAME,
  y = ~percent_hazard,
  type = "bar",
  color = ~analyte,
  colors = viridis::cividis(length(hazard_analytes), end = 0.9),
  hoverinfo = "text",
  text = ~paste0(round(percent_hazard, 1), "%"),
  textposition = "inside",
  hovertext = ~hover_text  # only non-zero analytes
) %>%
  layout(
    title = "Top 15 Counties with Hazard Index > 1",
    barmode = "stack",
    xaxis = list(title = "County", tickangle = -45),
    yaxis = list(title = "Hazard Contribution (%)", range = c(0, 100)),
    margin = list(b = 150),
    hoverlabel = list(
      bgcolor = "lightyellow",
      font = list(size = 12, color = "black"),
      bordercolor = "orange"
    )
  ) %>%
  onRender(js_auto_hover)

p_overall
```

```{r}
# Prepare metrics table for top 15 counties
metrics_table <- plot_data %>%
  group_by(NAME) %>%
  summarise(
    Analytes = paste(sort(unique(analyte)), collapse = ", "),
    `Dominant Analyte` = first(dominant_analyte),
    `Dominant Contribution` = first(dominant_hazard),
    `Total Hazard Index` = first(total_hazard),
    `Number of Sites` = sum(n_sites, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  rename(County = NAME) %>%
  arrange(desc(`Total Hazard Index`))

# Create reactable table
tbl_id <- "county_hazard_metrics_table"
rt <- reactable(
  metrics_table,
  elementId = tbl_id,
  columns = list(
    County = colDef(name = "COUNTY"),
    `Dominant Analyte` = colDef(name = "DOMINANT ANALYTE"),
    `Dominant Contribution` = colDef(name = "DOMINANT CONTRIBUTION"),
    `Total Hazard Index` = colDef(name = "TOTAL HAZARD INDEX"),
    `Number of Sites` = colDef(name = "NUMBER OF SITES")
  ),
  searchable = TRUE,
  filterable = TRUE,
  showPageSizeOptions = TRUE,
  defaultPageSize = 10,
  highlight = TRUE,
  bordered = TRUE,
  striped = TRUE
)

# Download button
download_btn <- tags$button(
  "Download CSV",
  onclick = sprintf("Reactable.downloadDataCSV('%s', 'county_hazard_metrics.csv')", tbl_id),
  style = "
    background: none;
    border: none;
    color: #0073e6;
    text-decoration: underline;
    cursor: pointer;
    font-size: 0.9em;
    float: right;
    margin-bottom: 5px;
  "
)

# Display table with download button
browsable(tagList(download_btn, rt))
```

```{r}
# Changing the system_type values to be more descriptive
public_water_max_long <- public_water_max_long |>
mutate(system_type = recode(system_type,
    "ADFSTC" = "Non-Community Water Supply (Adult Foster Care Provider)",
    "CHLCMP" = "Non-Community Water Supply (Children's Camp)",
    "DAYCARE" = "Non-Community Water Supply (Child Care Provider)",
    "INDUS" = "Non-Community Water Supply (Industry)",
    "MEDCAR" = "Non-Community Water Supply (Medical Care Provider)",
    "MOTEL" = "Non-Community Water Supply (Hotel or Motel)",
    "MUN" = "Community Water Supply (for example Municipal Supply, Apartment, Nursing Home, Prison, etc.)",
    "OFFICE" = "Office Building",
    "PARK" = "Park",
    "RESD" = "Residential",
    "SCH" = "School",
    "TRB" = "Tribal Lands"
  ))
```

### System Analysis
#### Hazard Index per System
```{r}
# Define main hazard analytes
hazard_analytes <- c("HFPODA", "PFNA", "PFBS", "PFHxS")

# Aggregate analyte-level hazard contributions by system
system_analytes <- public_water_max_long |>
  filter(
    Hazard_Index > 1,
    !is.na(analyte),
    analyte %in% hazard_analytes,
    !is.na(analyte_value),
    !is.na(system_name)
  ) |>
  mutate(
    system_name = tolower(system_name),
    analyte_hazard = case_when(
      analyte == "HFPODA" ~ analyte_value / 10,
      analyte == "PFNA"   ~ analyte_value / 10,
      analyte == "PFBS"   ~ analyte_value / 2000,
      analyte == "PFHxS"  ~ analyte_value / 10
    )
  ) |>
  group_by(system_name, analyte) |>
  summarise(
    total_hazard_analyte = sum(analyte_hazard, na.rm = TRUE),
    .groups = "drop"
  )

# Compute total hazard per system to identify top systems
system_total <- system_analytes |>
  group_by(system_name) |>
  summarise(
    total_hazard = sum(total_hazard_analyte, na.rm = TRUE),
    .groups = "drop"
  ) |>
  arrange(desc(total_hazard)) |>
  slice_head(n = 10)

# Filter analytes to top systems
system_analytes_top <- system_analytes |>
  filter(system_name %in% system_total$system_name) |>
  mutate(
    system_name = factor(system_name, levels = system_total$system_name)
  )

# Identify dominant analyte per system
dominant_per_system <- system_analytes_top |>
  group_by(system_name) |>
  slice_max(order_by = total_hazard_analyte, n = 1, with_ties = FALSE) |>
  ungroup() |>
  rename(dominant_analyte = analyte,
         dominant_hazard = total_hazard_analyte) |>
  select(system_name, dominant_analyte, dominant_hazard)

# Merge dominant info back for tooltip
system_analytes_top <- system_analytes_top |>
  left_join(dominant_per_system, by = "system_name")

# Create stacked hazard index contribution plot with tooltip showing only dominant analyte
p_system_hazard <- ggplot(
  system_analytes_top,
  aes(
    x = system_name,
    y = total_hazard_analyte,
    fill = analyte,
    text = paste(
      "<b>System:</b>", system_name,
      "<br><b>Dominant Analyte:</b>", dominant_analyte,
      "<br><b>Contribution:</b>", round(dominant_hazard, 2)
    )
  )
) +
  geom_col(width = 0.7, position = "stack") +
  scale_fill_viridis_d(option = "cividis", end = 0.9) +
  labs(
    title = "Hazard Index Decomposition for Top Systems",
    x = "System Name",
    y = "Hazard Index",
    fill = "Analyte",
    caption = "Data source: Michigan PFAS Action Response Team (MPART)"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.position = "right"
  )

# Convert to interactive Plotly chart with automatic hover
ggplotly(p_system_hazard, tooltip = "text") |>
  onRender(js_auto_hover) |>
  layout(
    hoverlabel = list(
      bgcolor = "lightyellow",
      font = list(color = "black", size = 12),
      bordercolor = "orange"
    )
  )

```

```{r}
# Summarize total hazard index per system type
summary_table <- public_water_max_long |>
  distinct(system_type, hex_id, Hazard_Index) |>  
  group_by(system_type) |>
  summarise(
    total_hazard = sum(Hazard_Index, na.rm = TRUE),
    n_sites = n(),
    .groups = "drop"
  ) |>
  # Round numeric columns to 2 decimal places
  mutate(across(where(is.numeric), ~ round(.x, 2))) |>
  arrange(desc(total_hazard))

# Assign a unique ID for reactable
tbl_id <- "system_type_hazard_table"

# Create the interactive table with uppercase headers
rt <- reactable(
  summary_table,
  elementId = tbl_id,
  columns = list(
    system_type = colDef(name = "SYSTEM TYPE"),
    total_hazard = colDef(name = "TOTAL HAZARD"),
    n_sites = colDef(name = "N SITES")
  ),
  searchable = TRUE,
  filterable = TRUE,
  showPageSizeOptions = TRUE,
  defaultPageSize = 10,
  highlight = TRUE,
  bordered = TRUE,
  striped = TRUE
)

# Create download link-style button in top-right
download_btn <- tags$button(
  "Download CSV",
  onclick = sprintf("Reactable.downloadDataCSV('%s', 'total_hazard_system_type.csv')", tbl_id),
  style = "
    background: none;
    border: none;
    color: #0073e6;
    text-decoration: underline;
    cursor: pointer;
    font-size: 0.9em;
    float: right;
    margin-bottom: 5px;
  "
)

# Display table with download link above it
browsable(tagList(download_btn, rt))
```

### System_Type Analysis
#### System Type Composition and decomposed contribution

```{r}
# Aggregate hazard contributions by system type
system_analytes_top <- public_water_max_long |>
  filter(
    Hazard_Index > 1,
    !is.na(analyte),
    analyte %in% hazard_analytes,
    !is.na(system_short)
  ) |>
  mutate(
    analyte_hazard = case_when(
      analyte == "HFPODA" ~ analyte_value / 10,
      analyte == "PFNA"   ~ analyte_value / 10,
      analyte == "PFBS"   ~ analyte_value / 2000,
      analyte == "PFHxS"  ~ analyte_value / 10
    )
  ) |>
  group_by(system_short, analyte) |>
  summarise(
    total_hazard_analyte = sum(analyte_hazard, na.rm = TRUE),
    .groups = "drop"
  )

# Compute total hazard per system_short and keep top 15
system_total <- system_analytes_top |>
  group_by(system_short) |>
  summarise(total_hazard = sum(total_hazard_analyte, na.rm = TRUE), .groups = "drop") |>
  arrange(desc(total_hazard)) |>
  slice_head(n = 15)

system_analytes_top <- system_analytes_top |>
  filter(system_short %in% system_total$system_short) |>
  mutate(system_short = factor(system_short, levels = system_total$system_short))

# Compute dominant analyte per system_short for tooltip
dominant_per_system <- system_analytes_top |>
  group_by(system_short) |>
  slice_max(order_by = total_hazard_analyte, n = 1, with_ties = FALSE) |>
  ungroup() |>
  rename(dominant_analyte = analyte,
         dominant_hazard = total_hazard_analyte) |>
  select(system_short, dominant_analyte, dominant_hazard)

# Merge dominant info back
system_analytes_top <- system_analytes_top |>
  left_join(dominant_per_system, by = "system_short")

# Create stacked bar plot with tooltip showing only dominant analyte + contribution
p_system_hazard <- ggplot(
  system_analytes_top,
  aes(
    x = system_short,
    y = total_hazard_analyte,
    fill = analyte,
    text = paste("<br><b>System Type:</b>", system_short,
      "<br><b>Dominant Analyte:</b>", dominant_analyte,
      "<br><b>Contribution:</b>", round(dominant_hazard, 2)
    )
  )
) +
  geom_col(width = 0.7, position = "stack") +
  scale_fill_viridis_d(option = "cividis", end = 0.9) +
  labs(
    title = "Hazard Index Decomposition for Top System Types",
    x = "System Type",
    y = "Hazard Index",
    fill = "Analyte",
    caption = "Data source: Michigan PFAS Action Response Team (MPART)"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.position = "right"
  )

# Convert to interactive Plotly chart with JS auto-hover
ggplotly(p_system_hazard, tooltip = "text") |>
  onRender(js_auto_hover) |>
  layout(
    hoverlabel = list(
      bgcolor = "mediumseagreen",
      font = list(color = "black", size = 12),
      bordercolor = "orange"
    )
  )

```

```{r}
# Filter system_type_table for top systems in the hazard plot
interactive_system_table <- system_type_map |>
  filter(short_name %in% system_total$system_short)

tbl_id <- "system_type_table"

# Create interactive table
rt_system <- reactable(
  interactive_system_table,
  elementId = tbl_id,
  searchable = TRUE,
  filterable = TRUE,
  showPageSizeOptions = TRUE,
  defaultPageSize = 10,
  highlight = TRUE,
  bordered = TRUE,
  striped = TRUE,
  columns = list(
    short_name = colDef(name = "SHORT NAME"),
    full_name  = colDef(name = "FULL DESCRIPTIVE NAME")
  )
)

# Create download button
download_btn <- tags$button(
  "Download CSV",
  onclick = sprintf("Reactable.downloadDataCSV('%s', 'system_type_table.csv')", tbl_id),
  style = "
    background: none;
    border: none;
    color: #0073e6;
    text-decoration: underline;
    cursor: pointer;
    font-size: 0.9em;
    float: right;
    margin-bottom: 5px;
  "
)

# Display table with download button
browsable(tagList(download_btn, rt_system))

```

### Site Analysis
#### Mean Hazard Index per Site
```{r}
# Filter merged_data for Hazard_Index > 1 and remove NA types
hazard_data <- merged_data |>
  filter(Hazard_Index > 1, !is.na(type)) |>
  distinct(hex_id, type, Hazard_Index)  

# Aggregate mean Hazard_Index and count of sites by site type
mean_by_type <- hazard_data |>
  group_by(type) |>
  summarise(
    mean_hazard = mean(Hazard_Index, na.rm = TRUE),
    n_sites = n(),
    .groups = "drop"
  )

# Order types by mean hazard descending and get top 15
top_types <- mean_by_type |>
  arrange(desc(mean_hazard)) |>
  slice_head(n = 15)

# Prepare plot data with factor levels for ordering
plot_data <- mean_by_type |>
  filter(type %in% top_types$type) |>
  mutate(type = factor(type, levels = top_types$type))

# Create ggplot object with tooltip text
p <- ggplot(plot_data, aes(
  x = type, 
  y = mean_hazard, 
  fill = type,
  text = paste("<br><b>Site Type:</b>",type,
    "<br><b>Mean Hazard Index:</b>", round(mean_hazard, 2),
               "<br><b>Number of Sites:</b>", n_sites)
)) +
  geom_col(position = position_dodge(width = 0.7), width = 0.7) +
  scale_fill_viridis_d(option = "cividis") +
  labs(
    title = "Mean Hazard Index by Site Type (Hazard_Index > 1)",
    x = "Site Type",
    y = "Mean Hazard Index (ppt)",
    fill = "Site Type",
    caption = "Data source: Michigan PFAS Action Response Team (MPART)"
  ) +
  theme_minimal() +
  theme(
    legend.position = "right",
    axis.text.x = element_text(angle = 45, hjust = 1)
  )

# Convert to interactive Plotly object with cycling tooltip
ggplotly(p, tooltip = "text") |>
  onRender("
    function(el) {
      var totalPoints = el.data[0].x.length;
      var i = 0;
      setInterval(function() {
        // Show tooltip for current bar
        Plotly.Fx.hover(el, [{ curveNumber: 0, pointNumber: i }], 'xy');
        i = (i + 1) % totalPoints;
      }, 2000);  // cycle every 2 seconds
    }
  ")
```


```{r}
# Visualizing the type of site by the composition of 4 main analytes with the hazard index
# Filter merged_data for Hazard_Index > 1, remove NA types, keep only main analytes
hazard_data <- merged_data |>
  filter(Hazard_Index > 1, !is.na(type)) |>
  distinct(hex_id, type, analyte, analyte_value, Hazard_Index) |>
  filter(analyte %in% hazard_analytes)

# Summarize total hazard and analyte sums by type
hazard_summary_by_type <- hazard_data |>
  group_by(type, analyte) |>
  summarise(sum_analyte = sum(analyte_value, na.rm = TRUE), .groups = "drop") |>
  # Total hazard per type
  left_join(
    hazard_data |>
      group_by(type) |>
      summarise(
        total_hazard = sum(Hazard_Index, na.rm = TRUE),
        n_sites = n_distinct(hex_id),
        .groups = "drop"
      ),
    by = "type"
  ) |>
  # Pivot analytes to columns
  pivot_wider(
    names_from = analyte,
    values_from = sum_analyte,
    values_fill = 0
  ) |>
  # Round all numeric columns to 2 decimal places
  mutate(across(where(is.numeric), ~ round(.x, 2))) |>
  arrange(desc(total_hazard))

# Assign a unique ID for reactable
tbl_id <- "hazard_summary_table"

# Create the interactive table with custom headers
rt <- reactable(
  hazard_summary_by_type,
  elementId = tbl_id,
  searchable = TRUE,
  filterable = TRUE,
  showPageSizeOptions = TRUE,
  defaultPageSize = 10,
  highlight = TRUE,
  bordered = TRUE,
  striped = TRUE,
  columns = list(
    type = colDef(name = "TYPE"),
    total_hazard = colDef(name = "TOTAL HAZARD"),
    n_sites = colDef(name = "N SITES")
    # You can add analyte-specific headers here if needed, e.g.:
    # `Lead` = colDef(name = "LEAD"),
    # `Arsenic` = colDef(name = "ARSENIC")
  )
)

# Create download link-style button in top-right
download_btn <- tags$button(
  "Download CSV",
  onclick = sprintf("Reactable.downloadDataCSV('%s', 'hazard_summary_by_type.csv')", tbl_id),
  style = "
    background: none;
    border: none;
    color: #0073e6;
    text-decoration: underline;
    cursor: pointer;
    font-size: 0.9em;
    float: right;
    margin-bottom: 5px;
  "
)

# Display table with download link above it
browsable(tagList(download_btn, rt))

```


### Temporal Analysis
#### Trends in Hazard Index and Analytes
