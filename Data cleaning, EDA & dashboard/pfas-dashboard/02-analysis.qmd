---
title: "Public Water Hazard Index Analysis"
format:
  dashboard:
    orientation: rows 
    theme: flatly            
    toc: true              
    self-contained: true   
execute:
  echo: false
  warning: false
  message: false
  output: true
---

```{r}
#| include: false
set.seed(1994)

# Loading necessary packages
library(tidyverse)
library(naniar)
library(janitor)
library(sf)
library(gt)
library(skimr)
library(tidycensus)
library(maps)
library(patchwork)
library(ggrepel)
library(ggthemes)
library(scales)
library(reshape2)
library(ggcorrplot)
library(flextable)
library(dplyr)
library(tidyr)
library(plotly)
library(leaflet)
library(reactable)
library(reactablefmtr)
library(htmltools)
library(leaflet.extras2)
library(leaflegend)
library(htmlwidgets)
library(leaflet.extras)
library(crosstalk)
library(stringr)
library(forcats)



# Function for creating data dictionary
data_dictionary <- function(myData, descripts) {
tibble(Variable = colnames(myData),
       Type = map_chr(myData, .f = function(x){typeof(x)[1]}),
       Description = descripts) |> 
  gt()
}
```

```{r PFAS_packages}
#| eval: true
#| include: false

# Create function to add geoid variable given longitude and latitude for county-level data
add_geoid <- function(my_data) {
  # Create sf object to help add geoid column
my_data_sf <- my_data |> 
st_as_sf(coords = c("longitude", "latitude"))

# Set coordinate reference system (CRS) to match counties data
counties <- st_read("GeoFiles//cb_2018_us_county_500k.shp")
st_crs(my_data_sf) <- st_crs(counties)

ret_data <- my_data_sf |> 
  st_join(counties) |> 
    mutate(longitude = st_coordinates(geometry)[, 1],
           latitude = st_coordinates(geometry)[, 2]) |> 
  st_drop_geometry() |> 
  as_tibble() |> 
  dplyr::select(GEOID, longitude, latitude) |> 
  dplyr::rename(geoid = GEOID) |> 
  distinct() |> 
  right_join(my_data)

return(ret_data)
}
```


```{r PFAS_surface_clean}
#| eval: true
#| include: false

# Importing data on PFAS levels in surface water in Michigan
analyte_info <- read_csv("PFAS_Surface_Water_Sampling.csv") |> 
              dplyr::select(-c(X:Latitude, GlobalID, OBJECTID,
                               ends_with("Flag")))

surface_water <- read_csv("PFAS_Surface_Water_Sampling.csv") |> 
  clean_names() |> 
  dplyr::select(-ends_with("_flag")) |> 
  dplyr::select(-c(cas307244_pf_hx_a:cas919005144_adona_rl)) |> 
  bind_cols(analyte_info)

# Importing data on surface water data dictionary
surface_water_dictionary <- read_csv("surface_water_data_dictionary.csv")

# Creating long version of surface water data
surface_water_long <- surface_water |> 
  dplyr::rename(object_id = objectid) |> 
  dplyr::select(longitude, latitude, object_id, everything(), 
                -c(x:y), -ends_with("Flag"), -global_id) |> 
  pivot_longer(cols = colnames(analyte_info), 
               names_to = "analyte", 
               values_to = "analyte_value") |> 
  dplyr::select(-matrix, -unit, -object_id) |> 
  add_geoid()

# Saving to external CSV
write_csv(surface_water_long, file = "pfas_surface_water_long.csv")
```


```{r PFAS_public_clean}
#| eval: true
#| include: false

# Importing shape file data for public water supply PFAS levels data
public_water_shape <- st_read("Public_Water_Supply_Sampling_Hexbins_and_Results/Public_Water_Supply_Sampling_Hexbins.shp") |> 
  mutate(centroid = st_centroid(geometry),
         longitude = st_coordinates(centroid)[, 1],
         latitude = st_coordinates(centroid)[, 2]) |> 
  dplyr::select(HexID, longitude, latitude) |> 
  st_drop_geometry() |> 
  as_tibble()

# Importing data on public water supply PFAS levels
public_water <- read_csv("Public_Water_Supply_Sampling_Hexbins_and_Results.csv")

# Adding geoid, longitude, and latitude information to public water data
# and cleaning variable names
public_water_wide <- public_water |> 
  left_join(public_water_shape, by = "HexID") |> 
  dplyr::select(-ends_with(c("Result", "Flags"))) |> 
  clean_names() |> 
  dplyr::rename(object_id = objectid) |> 
  dplyr::select(object_id:sys_loc_code, longitude, latitude, everything()) |> 
  bind_cols(dplyr::select(public_water, ends_with("Result"))) |> 
  add_geoid()

# Pivoting public water data from wide to long format
public_water_long <- public_water_wide |> 
  pivot_longer(cols = c(ends_with(c("Result"))), 
               names_to = "analyte", 
               values_to = "analyte_value") |> 
  mutate(analyte = gsub(analyte, pattern = "Result", replacement = "")) |> 
  dplyr::select(-c(hex_id, 
                   wssn, loc_name:sys_loc_code, 
                   phase_code:task_type,
                   treatment_status:sys_sample_code,
                   lab_number:lab_sdg, 
                   object_id, position_source,
                   analytical_method,
                   sampling_results_count)) |> 
  mutate(system_type = fct_recode(system_type,
                               "Non-Community Water Supply (Adult Foster Care Provider)" = "ADFSTC",
                               "Non-Community Water Supply (Children's Camp)" = "CHLCMP",
                               "Non-Community Water Supply (Child Care Provider)" = "DAYCARE",
                               "Non-Community Water Supply (Industry)" = "INDUS",
                               "Non-Community Water Supply (Medical Care Provider)" = "MEDCAR",
                               "Non-Community Water Supply (Hotel or Motel)" = "MOTEL",
                               "Community Water Supply (for example Municipal Supply, Apartment, Nursing Home, Prison, etc.)" = "MUN",
                               "Office Building" = "OFFICE",
                               "Park" = "PARK",
                               "Residential" = "RESD",
                               "School" = "SCH",
                               "Tribal Lands" = "TRB"))


# Saving to external CSV
write_csv(public_water_long, file = "pfas_public_water_long.csv")
```


```{r PFAS_sites_import}
#| eval: true
#| include: false

pfas_site_path <- "pfas_sites.csv"

if(file.exists(pfas_site_path) == FALSE) {
# Importing data on identified sites from https://www.michigan.gov/pfasresponse
# Downloaded on 02/25/2025
pfas_sites <- read_csv("Michigan_PFAS_Sites.csv") |> 
  janitor::clean_names() |> 
  dplyr::select(facility:site_type, location:military, facility_date, site_background:anticipated_activities, -tier, -site_type) |> 
  add_geoid()

# Saving cleaned data
write_csv(pfas_sites, file = pfas_site_path)
} else {
  # Importing
  pfas_sites <- read_csv(pfas_site_path)
}
```

```{r}
# Drop flag columns, replace NA in PFAS Result columns with 0, and ensure numeric
public_water_wide <- public_water_wide |> 
  select(-ends_with("Flags")) |> 
  mutate(across(ends_with("Result"), ~replace_na(as.numeric(.x), 0)))

# Calculating the hazard index
public_water_wide <- public_water_wide |>
  mutate(Hazard_Index = (HFPODAResult / 10) +
         (PFNAResult / 10) +
         (PFBSResult / 2000) +
         (PFHxSResult / 10))
```


```{r}
# Displaying the high index areas with the highest analyte contributor in a table
high_hazard <- public_water_wide |> 
  filter(Hazard_Index > 1) |> 
  select(hex_id, sample_date, Hazard_Index, HFPODAResult, PFNAResult, PFBSResult, PFHxSResult) |> 
  arrange(desc(Hazard_Index)) |> 
  flextable() |> 
  set_caption("Public Water Locations with Hazard Index > 1") |> 
  autofit()
```

```{r}
# Extracting the maximum hazard per hex ID
public_water_max <- public_water_wide |> 
  group_by(hex_id) |> 
  slice_max(order_by = Hazard_Index, n = 1, with_ties = FALSE) |> 
  ungroup()
```


```{r}
# Changing the wide format to long format
public_water_max_long <- public_water_max |>
pivot_longer(cols = ends_with("Result"),   
               names_to = "analyte",
               values_to = "analyte_value") |>
mutate(analyte = gsub("Result$", "", analyte))
```


```{r}
merged_data <- public_water_max_long |>
  left_join(
    pfas_sites |> mutate(geoid = as.character(geoid)), 
    by = "geoid",
    relationship = "many-to-many"
  )
```

```{r}
# Reusable JS for auto-hover
js_auto_hover <- "
function(el, x) {
  // Determine number of points depending on chart orientation
  var d = el.data[0];
  var totalPoints = 0;

  if (d.x && d.x.length > 0) {
    totalPoints = d.x.length;   // vertical bars or line charts
  } 
  if (d.y && d.y.length > 0) {
    totalPoints = d.y.length;   // horizontal bars
  }

  var i = 0;
  setInterval(function() {
    Plotly.Fx.hover(el, [{ curveNumber: 0, pointNumber: i }], 'xy');
    i = (i + 1) % totalPoints;
  }, 2000);
}
"
```

```{r}
# Reusable JS for auto-hover on pie charts
js_auto_hover_pie <- "
function(el, x) {
  var totalSlices = el.data[0].labels.length; // number of pie slices
  var i = 0;
  setInterval(function() {
    Plotly.Fx.hover(el, [{ curveNumber: 0, pointNumber: i }]);
    i = (i + 1) % totalSlices;
  }, 2000);
}
"
```

```{r}
# Prepare system type mapping
system_type_map <- tibble(
  short_name = c(
    "ADFSTC", "CHLCMP", "DAYCARE", "INDUS", "MEDCAR",
    "MOTEL", "MUN", "OFFICE", "PARK", "RESD", "SCH", "TRB"
  ),
  full_name = c(
    "Non-Community Water Supply (Adult Foster Care Provider)",
    "Non-Community Water Supply (Children's Camp)",
    "Non-Community Water Supply (Child Care Provider)",
    "Non-Community Water Supply (Industry)",
    "Non-Community Water Supply (Medical Care Provider)",
    "Non-Community Water Supply (Hotel or Motel)",
    "Community Water Supply (for example Municipal Supply, Apartment, Nursing Home, Prison, etc.)",
    "Office Building",
    "Park",
    "Residential",
    "School",
    "Tribal Lands"
  )
)

# Apply short names to the dataset
public_water_max_long <- public_water_max_long |>
  mutate(system_short = recode(system_type,
    "Non-Community Water Supply (Adult Foster Care Provider)" = "ADFSTC",
    "Non-Community Water Supply (Children's Camp)" = "CHLCMP",
    "Non-Community Water Supply (Child Care Provider)" = "DAYCARE",
    "Non-Community Water Supply (Industry)" = "INDUS",
    "Non-Community Water Supply (Medical Care Provider)" = "MEDCAR",
    "Non-Community Water Supply (Hotel or Motel)" = "MOTEL",
    "Community Water Supply (for example Municipal Supply, Apartment, Nursing Home, Prison, etc.)" = "MUN",
    "Office Building" = "OFFICE",
    "Park" = "PARK",
    "Residential" = "RESD",
    "School" = "SCH",
    "Tribal Lands" = "TRB"
  ))
```

## PFAS Concentration

```{r PFAS_surface_explore}
#| include: false
#| eval: true
# Aggregating PFAS values for most recent measurement of each site
surface_water_total <- surface_water_long |> 
  dplyr::mutate(watershed = case_when(watershed == "Huron" ~ "Lake Huron",
                                      TRUE ~ watershed)) |> 
  group_by(geoid, longitude, latitude, site_code, location_code, watershed, waterbody) |> 
  slice_max(collection_date, n = 1) |> 
  group_by(geoid, longitude, latitude, collection_date, site_code, location_code, watershed, waterbody) |> 
  summarize(total_analytes = sum(analyte_value, na.rm = TRUE)) |> 
  ungroup()

```

```{r}
# Standardizing the variable names in the data sets
standardize_column_names <- function(df) {
  df |> janitor::clean_names()
}

# Apply to data sets
public_water_long_conc <- public_water_long |> standardize_column_names()
surface_water_long <- surface_water_long |> standardize_column_names()
pfas_sites_conc <- pfas_sites |> standardize_column_names()
```

```{r}
# Function to clean string columns (excluding numeric and analyte columns)
clean_strings_title_case <- function(df) {
  # Columns to clean
  cols_to_clean <- df %>%
    select(where(is.character)) %>%      
    select(-matches("analyte", ignore.case = TRUE)) %>%  
    colnames()
  
  # Applying title case to selected columns
  df %>%
    mutate(across(all_of(cols_to_clean), str_to_title))
}

# Application to datasets
public_water_long_conc <- clean_strings_title_case(public_water_long)
surface_water_long <- clean_strings_title_case(surface_water_long)
pfas_sites_conc <- clean_strings_title_case(pfas_sites)
```

```{r}
# Function to get maximum analyte value per site
get_max_concentration <- function(df, site_col, analyte_col, value_col) {
  df_max <- df |>
    # Step 0: Replace NAs in analyte and value columns with 0
    mutate(
      !!analyte_col := ifelse(is.na(.data[[analyte_col]]), 0, .data[[analyte_col]]),
      !!value_col := ifelse(is.na(.data[[value_col]]), 0, .data[[value_col]])
    ) |>
    
    # Step 1: Group by site and analyte
    group_by(across(all_of(c(site_col, analyte_col)))) |>
    
    # Step 2: Select the row with the highest analyte value within each group
    slice_max(order_by = .data[[value_col]], n = 1, with_ties = FALSE) |>
    
    # Step 3: Ungroup
    ungroup()

  return(df_max)
}

```

```{r}
# Application in surface water
surface_max_full <- get_max_concentration(
  df = surface_water_long,
  site_col = "site_code",
  analyte_col = "analyte",
  value_col = "analyte_value"
)

# Application in public water
public_max_full <- get_max_concentration(
  df = public_water_long_conc,
  site_col = "system_name",
  analyte_col = "analyte",
  value_col = "analyte_value"
)
```


## Hazard Index Analysis {.tabset}

### Hazard Composition
#### Analyte Composition
```{r}
# Define main hazard analytes
hazard_analytes <- c("HFPODA", "PFNA", "PFBS", "PFHxS")
hazard_colors <- c("HFPODA" = "#575c6d", "PFNA" = "#a69d75", "PFBS" = "#ffea47", "PFHxS" = "#00204d")

# Aggregate analyte-level hazard contributions across all hexes
total_analyte_hazard <- public_water_max_long |>
  filter(analyte %in% hazard_analytes) |>           
  mutate(analyte_hazard = case_when(
    analyte == "HFPODA" ~ analyte_value / 10,
    analyte == "PFNA"   ~ analyte_value / 10,
    analyte == "PFBS"   ~ analyte_value / 2000,
    analyte == "PFHxS"  ~ analyte_value / 10
  )) |>
  group_by(analyte) |>
  summarise(
    total_contribution = sum(analyte_hazard, na.rm = TRUE),
    .groups = "drop"
  ) |>
  arrange(desc(total_contribution)) |>
  mutate(
    percent = round(total_contribution / sum(total_contribution) * 100, 1),
    analyte = factor(analyte, levels = analyte)
  )

# JS for automatic hover (consistent with your other plots)
js_auto_hover <- "
function(el, x) {
  var totalBars = el.data[0].x.length;
  var i = 0;
  setInterval(function() {
    Plotly.Fx.hover(el, [{ curveNumber: 0, pointNumber: i }], 'xy');
    i = (i + 1) % totalBars;
  }, 2000);
}
"

# Extend y-axis to prevent clipped text
y_max <- max(total_analyte_hazard$total_contribution, na.rm = TRUE) * 1.15

# Create Plotly bar chart with cividis palette
p_bar <- plot_ly(
  data = total_analyte_hazard,
  x = ~analyte,
  y = ~total_contribution,
  type = "bar",
  color = ~analyte,
  colors = viridis::viridis(
    n = length(unique(total_analyte_hazard$analyte)),
    option = "cividis"
  ),
  text = ~paste0(percent, "%"),
  textposition = "outside",
  hoverinfo = "text",
  hovertext = ~paste(
    "<b>Analyte:</b>", analyte,
    "<br><b>Total Contribution:</b>", round(total_contribution, 2),
    "<br><b>Percent of Total:</b>", percent, "%"
  )
) |>
  layout(
    title = "Total Decomposed Hazard Index Contributions by Analyte",
    xaxis = list(title = "Analyte"),
    yaxis = list(
      title = "Total Hazard Index Contribution",
      range = c(0, y_max)
    ),
    showlegend = FALSE,
    margin = list(t = 80),
    hoverlabel = list(
      bgcolor = "lightyellow",
      font = list(color = "black", size = 12),
      bordercolor = "orange"
    )
  ) |>
  onRender(js_auto_hover)

p_bar
```

```{r}
# Define main hazard analytes
hazard_analytes <- c("HFPODA", "PFNA", "PFBS", "PFHxS")

# Load Michigan counties shapefile (FIX: transform to WGS84)
mi_counties <- st_read("GeoFiles/cb_2018_us_county_500k.shp", quiet = TRUE) %>%
  filter(STATEFP == "26") %>%
  st_transform(4326)

# Prepare analyte-wide data
analyte_wide <- public_water_max_long %>%
  filter(analyte %in% hazard_analytes) %>%
  select(hex_id, analyte, analyte_value) %>%
  pivot_wider(
    names_from = analyte,
    values_from = analyte_value,
    values_fill = 0
  )

# Prepare hazard sites
hazard_sites_full <- public_water_max_long %>%
  filter(Hazard_Index > 1) %>%
  distinct(hex_id, system_name, system_type, Hazard_Index, longitude, latitude) %>%
  rename(type = system_type) %>%
  left_join(analyte_wide, by = "hex_id") %>%
  st_as_sf(coords = c("longitude", "latitude"), crs = 4326) %>%
  mutate(
    Hazard_Index = as.numeric(Hazard_Index),
    search_field = system_name
  )

# LOWERCASE ONLY SYSTEM STRINGS (analytes untouched)
hazard_sites_full <- hazard_sites_full %>%
  mutate(
    system_name = tolower(system_name),
    type = tolower(type),
    search_field = tolower(search_field)
  )

# Color palette (UPDATED)
max_radius <- 20
desired_max <- max(hazard_sites_full$Hazard_Index, na.rm = TRUE)
max_val <- ceiling(desired_max / 5) * 5

hazard_pal <- colorNumeric(
  palette = "YlOrRd",
  domain = c(0, max_val)
)

# Compute scaled radius BEFORE SharedData
hazard_sites_full <- hazard_sites_full %>%
  mutate(scaled_radius = sqrt(Hazard_Index / max(Hazard_Index, na.rm = TRUE)) * max_radius)

# Crosstalk SharedData
shared_data <- SharedData$new(
  hazard_sites_full,
  key = ~hex_id,
  group = "hazard"
)

# Popups
hazard_popup <- hazard_sites_full %>%
  mutate(popup = paste0(
    "<b>System Name:</b> ", system_name, "<br>",
    "<b>Type:</b> ", type, "<br>",
    "<b>Hazard Index:</b> ", round(Hazard_Index, 2), "<br>",
    "<b>HFPODA:</b> ", round(HFPODA, 2), "<br>",
    "<b>PFNA:</b> ", round(PFNA, 2), "<br>",
    "<b>PFBS:</b> ", round(PFBS, 2), "<br>",
    "<b>PFHxS:</b> ", round(PFHxS, 2)
  ))

# Legend data for bubble legend (fixed scale of 5)
legend_data <- tibble(
  Hazard_Index = seq(5, max_val, by = 5)
) %>%
  mutate(scaled_radius = sqrt(Hazard_Index / max_val) * max_radius)

# Crosstalk filter widget (top of page)
filter_widget <- filter_select(
  id = "system_filter",
  label = "Filter by System Name",
  sharedData = shared_data,
  group = ~search_field
)

# Build interactive Leaflet map with bubble legend + Crosstalk
bscols(
  widths = 12,   # FULL WIDTH MAP
  filter_widget,
  
  leaflet(shared_data) %>%
    setView(lng = -84.5, lat = 44.5, zoom = 6) %>%
    
    addProviderTiles(providers$CartoDB.Positron) %>%
    
    addPolygons(
      data = mi_counties,
      fillColor = "grey",
      color = "black",
      weight = 1,
      fillOpacity = 0.3,
      label = ~NAME
    ) %>%
    
    addCircleMarkers(
      radius = ~scaled_radius,
      fillColor = ~hazard_pal(Hazard_Index),
      color = "black",
      fillOpacity = 0.7,
      stroke = TRUE,
      weight = 0.5,
      label = lapply(hazard_popup$popup, HTML),
      labelOptions = labelOptions(
        direction = "auto",
        textsize = "12px",
        opacity = 0.9,
        offset = c(0, -5)
      )
    ) %>%
    
    addLegendSize(
      values = legend_data$Hazard_Index,
      pal = hazard_pal,
      title = "Hazard Index",
      baseSize = max_radius,
      shape = "circle",
      orientation = "vertical",
      opacity = 1,
      fillOpacity = 0.7,
      position = "bottomright",
      breaks = legend_data$Hazard_Index
    )
)

```

#### Michigan PFAS Map

```{r}
#| eval: false
#| include: false

# Define main hazard analytes
hazard_analytes <- c("HFPODA", "PFNA", "PFBS", "PFHxS")

# Load Michigan counties shapefile
mi_counties <- st_read("GeoFiles/cb_2018_us_county_500k.shp", quiet = TRUE) %>%
  filter(STATEFP == "26") %>%
  st_transform(4326)   

# Prepare analyte-wide data
analyte_wide <- public_water_max_long %>%
  filter(analyte %in% hazard_analytes) %>%
  select(hex_id, analyte, analyte_value) %>%
  pivot_wider(
    names_from = analyte,
    values_from = analyte_value,
    values_fill = 0
  )

# Prepare hazard sites (sf)
hazard_sites_full <- public_water_max_long %>%
  filter(Hazard_Index > 1) %>%
  distinct(hex_id, system_name, system_type, Hazard_Index, longitude, latitude) %>%
  rename(type = system_type) %>%
  left_join(analyte_wide, by = "hex_id") %>%
  st_as_sf(coords = c("longitude", "latitude"), crs = 4326) %>%
  mutate(
    Hazard_Index = as.numeric(Hazard_Index),
    popup_label = paste0(
      "<b>System Name:</b> ", system_name, "<br>",
      "<b>Type:</b> ", type, "<br>",
      "<b>Hazard Index:</b> ", round(Hazard_Index, 2)
    )
  )

# Color palette + scaled radius
max_radius <- 20

hazard_pal <- colorNumeric(
  palette = "YlOrRd",
  domain = hazard_sites_full$Hazard_Index
)

hazard_sites_full <- hazard_sites_full %>%
  mutate(
    scaled_radius = sqrt(Hazard_Index / max(Hazard_Index, na.rm = TRUE)) * max_radius
  )

# Build searchable field (use system_name instead of type)
hazard_sites_full <- hazard_sites_full %>%
  mutate(
    search_field = system_name
  )

# SharedData for Crosstalk
shared_data <- SharedData$new(
  hazard_sites_full,
  key = ~hex_id,
  group = "hazard"
)

# FILTER WIDGET (Hazard Index)
filter_widget <- filter_slider(
  id = "hazard_filter",
  label = "Filter by Hazard Index",
  sharedData = shared_data,
  column = ~Hazard_Index,
  min = min(hazard_sites_full$Hazard_Index, na.rm = TRUE),
  max = max(hazard_sites_full$Hazard_Index, na.rm = TRUE),
  step = 0.1
)

# LEAFLET MAP
map_widget <- shared_data %>%
  leaflet() %>%
  setView(lng = -84.5, lat = 44.5, zoom = 6) %>%

  addProviderTiles(providers$CartoDB.Positron) %>%

  addPolygons(
    data = mi_counties,
    fillColor = "grey",
    color = "black",
    weight = 1,
    fillOpacity = 0.3
  ) %>%

  addCircleMarkers(
    radius = ~scaled_radius,
    fillColor = ~hazard_pal(Hazard_Index),
    color = "black",
    fillOpacity = 0.7,
    stroke = TRUE,
    weight = 0.5,
    popup = ~popup_label,
    label = ~lapply(popup_label, HTML),
    layerId = ~search_field,
    group = "HazardSites"
  ) %>%

  addLabelOnlyMarkers(
    lng = ~st_coordinates(geometry)[,1],
    lat = ~st_coordinates(geometry)[,2],
    label = ~round(Hazard_Index, 1),
    labelOptions = labelOptions(
      noHide = TRUE,
      textOnly = TRUE,
      style = list(
        "color" = "black",
        "font-size" = "10px",
        "font-weight" = "bold",
        "text-shadow" = "1px 1px 2px white"
      )
    )
  ) %>%

  addSearchFeatures(
    targetGroups = "HazardSites",
    options = searchFeaturesOptions(
      zoom = 11,
      openPopup = TRUE,
      firstTipSubmit = TRUE,
      autoCollapse = TRUE,
      hideMarkerOnCollapse = TRUE,
      propertyName = "layerId",
      textPlaceholder = "Search by system name..."
    )
  ) %>%

  addControl(
    html = htmltools::div(
      id = "filter-container",
      style = "background: rgba(255,255,255,0.85); padding: 10px; border-radius: 5px;",
      filter_widget
    ),
    position = "topright"
  ) %>%

  onRender("
    function(el, x) {
      var container = document.getElementById('filter-container');
      if (container) {
        L.DomEvent.disableScrollPropagation(container);
        L.DomEvent.disableClickPropagation(container);
      }
    }
  ")

map_widget


```


### County Analysis
#### Top 15 Hazard > 1

```{r}
# JS for automatic bar hover
js_auto_hover <- "
function(el, x) {
  var totalPoints = el.data[0].y.length;
  var i = 0;
  setInterval(function() {
    Plotly.Fx.hover(el, [{ curveNumber: 0, pointNumber: i }], 'xy');
    i = (i + 1) % totalPoints;
  }, 2000);
}
"

# Define main hazard analytes
hazard_analytes <- c("HFPODA", "PFNA", "PFBS", "PFHxS")

# Aggregate analyte-level hazard contributions per county
county_analytes <- public_water_max_long %>%
  filter(
    Hazard_Index > 1,
    analyte %in% hazard_analytes,
    !is.na(analyte_value)
  ) %>%
  mutate(
    analyte_hazard = case_when(
      analyte == "HFPODA" ~ analyte_value / 10,
      analyte == "PFNA"   ~ analyte_value / 10,
      analyte == "PFBS"   ~ analyte_value / 2000,
      analyte == "PFHxS"  ~ analyte_value / 10
    )
  ) %>%
  group_by(geoid, analyte) %>%
  summarise(
    total_hazard_analyte = sum(analyte_hazard, na.rm = TRUE),
    n_sites = n_distinct(system_name),
    .groups = "drop"
  )

# Join county names and remove unknown counties
county_info <- st_read("GeoFiles/cb_2018_us_county_500k.shp", quiet = TRUE) %>%
  st_drop_geometry() %>%
  select(GEOID, NAME)

county_analytes <- county_analytes %>%
  left_join(county_info, by = c("geoid" = "GEOID")) %>%
  filter(!is.na(NAME))

# Compute total hazard per county to get top 15
county_total <- county_analytes %>%
  group_by(NAME) %>%
  summarise(
    total_hazard = sum(total_hazard_analyte, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  arrange(desc(total_hazard)) %>%
  slice_head(n = 15)

# Identify dominant analyte per county for tooltip
dominant_per_county <- county_analytes %>%
  filter(NAME %in% county_total$NAME) %>%
  group_by(NAME) %>%
  slice_max(total_hazard_analyte, n = 1, with_ties = FALSE) %>%
  ungroup() %>%
  select(NAME, dominant_analyte = analyte, dominant_hazard = total_hazard_analyte)

# Prepare plot data: top 15 counties only, ordered by total hazard
plot_data <- county_analytes %>%
  filter(NAME %in% county_total$NAME) %>%
  left_join(dominant_per_county, by = "NAME") %>%
  left_join(county_total, by = "NAME") %>%
  arrange(desc(total_hazard)) %>%
  mutate(NAME = factor(NAME, levels = unique(NAME)))  # enforce descending order

# Create Plotly stacked bar chart
p_overall <- plot_ly(
  data = plot_data,
  x = ~NAME,
  y = ~total_hazard_analyte,
  type = "bar",
  color = ~analyte,
  colors = viridis::cividis(length(hazard_analytes), end = 0.9),
  hoverinfo = "text",
  text = ~round(total_hazard_analyte, 2),
  textposition = "inside",
  hovertext = ~paste0(
    "<b>County:</b> ", NAME,
    "<br><b>Total Hazard Index:</b> ", round(total_hazard, 2),
    "<br><b>Dominant Analyte:</b> ", dominant_analyte,
    "<br><b>Contribution of Dominant Analyte:</b> ", round(dominant_hazard, 2),
    "<br><b>Number of Sites:</b> ", n_sites
  )
) %>%
  layout(
    title = "Top 15 Counties with Hazard Index >1",
    barmode = "stack",
    xaxis = list(title = "County", tickangle = -45),
    yaxis = list(title = "Hazard Index"),
    margin = list(b = 150),
    hoverlabel = list(
      bgcolor = "lightyellow",
      font = list(size = 12, color = "black"),
      bordercolor = "orange"
    )
  ) %>%
  onRender(js_auto_hover)

p_overall

```

```{r}
# JS for automatic bar hover
js_auto_hover <- "
function(el, x) {
  var totalPoints = el.data[0].y.length;
  var i = 0;
  setInterval(function() {
    Plotly.Fx.hover(el, [{ curveNumber: 0, pointNumber: i }], 'xy');
    i = (i + 1) % totalPoints;
  }, 2000);
}
"

# Define main hazard analytes
hazard_analytes <- c("HFPODA", "PFNA", "PFBS", "PFHxS")

# Aggregate analyte-level hazard contributions per county
county_analytes <- public_water_max_long %>%
  filter(
    Hazard_Index > 1,
    analyte %in% hazard_analytes,
    !is.na(analyte_value)
  ) %>%
  mutate(
    analyte_hazard = case_when(
      analyte == "HFPODA" ~ analyte_value / 10,
      analyte == "PFNA"   ~ analyte_value / 10,
      analyte == "PFBS"   ~ analyte_value / 2000,
      analyte == "PFHxS"  ~ analyte_value / 10
    )
  ) %>%
  group_by(geoid, analyte) %>%
  summarise(
    total_hazard_analyte = sum(analyte_hazard, na.rm = TRUE),
    n_sites = n_distinct(system_name),
    .groups = "drop"
  )

# Join county names
county_info <- st_read("GeoFiles/cb_2018_us_county_500k.shp", quiet = TRUE) %>%
  st_drop_geometry() %>%
  select(GEOID, NAME)

county_analytes <- county_analytes %>%
  left_join(county_info, by = c("geoid" = "GEOID")) %>%
  filter(!is.na(NAME))

# Compute total hazard per county to get top 15
county_total <- county_analytes %>%
  group_by(NAME) %>%
  summarise(
    total_hazard = sum(total_hazard_analyte, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  arrange(desc(total_hazard)) %>%
  slice_head(n = 15)

# Compute % contribution per analyte and prepare hover text
plot_data <- county_analytes %>%
  filter(NAME %in% county_total$NAME) %>%
  left_join(county_total, by = "NAME") %>%
  group_by(NAME) %>%
  mutate(
    percent_hazard = 100 * total_hazard_analyte / total_hazard
  ) %>%
  ungroup() %>%
  arrange(desc(total_hazard)) %>%
  mutate(NAME = factor(NAME, levels = unique(NAME)))

# Compute dominant analyte per county
dominant_per_county <- plot_data %>%
  group_by(NAME) %>%
  slice_max(total_hazard_analyte, n = 1, with_ties = FALSE) %>%
  ungroup() %>%
  select(NAME, dominant_analyte = analyte, dominant_hazard = total_hazard_analyte)

# Hover text per county: only non-zero analytes
hover_text_per_county <- plot_data %>%
  filter(percent_hazard > 0) %>%
  group_by(NAME) %>%
  summarise(
    hover_text = paste0(analyte, ": ", round(percent_hazard, 1), "%", collapse = "<br>"),
    .groups = "drop"
  )

# Join dominant analyte and hover text
plot_data <- plot_data %>%
  left_join(dominant_per_county, by = "NAME") %>%
  left_join(hover_text_per_county, by = "NAME")

# Create Plotly stacked bar chart
p_overall <- plot_ly(
  data = plot_data,
  x = ~NAME,
  y = ~percent_hazard,
  type = "bar",
  color = ~analyte,
  colors = viridis::cividis(length(hazard_analytes), end = 0.9),
  hoverinfo = "text",
  text = ~paste0(round(percent_hazard, 1), "%"),
  textposition = "inside",
  hovertext = ~hover_text  # only non-zero analytes
) %>%
  layout(
    title = "Top 15 Counties with Hazard Index > 1",
    barmode = "stack",
    xaxis = list(title = "County", tickangle = -45),
    yaxis = list(title = "Hazard Contribution (%)", range = c(0, 100)),
    margin = list(b = 150),
    hoverlabel = list(
      bgcolor = "lightyellow",
      font = list(size = 12, color = "black"),
      bordercolor = "orange"
    )
  ) %>%
  onRender(js_auto_hover)

p_overall
```

```{r}
# Prepare metrics table for top 15 counties
metrics_table <- plot_data %>%
  group_by(NAME) %>%
  summarise(
    `Dominant Analyte` = first(dominant_analyte),
    `Dominant Contribution` = first(dominant_hazard),
    `Total Hazard Index` = first(total_hazard),
    `Number of Sites` = sum(n_sites, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  rename(County = NAME) %>%
  arrange(desc(`Total Hazard Index`))

# Create reactable table
tbl_id <- "county_hazard_metrics_table"
rt <- reactable(
  metrics_table,
  elementId = tbl_id,
  columns = list(
    County = colDef(name = "COUNTY"),
    `Dominant Analyte` = colDef(name = "DOMINANT ANALYTE"),
    `Dominant Contribution` = colDef(name = "DOMINANT CONTRIBUTION"),
    `Total Hazard Index` = colDef(name = "TOTAL HAZARD INDEX"),
    `Number of Sites` = colDef(name = "NUMBER OF SITES")
  ),
  searchable = TRUE,
  filterable = TRUE,
  showPageSizeOptions = TRUE,
  defaultPageSize = 10,
  highlight = TRUE,
  bordered = TRUE,
  striped = TRUE
)

# Download button
download_btn <- tags$button(
  "Download CSV",
  onclick = sprintf("Reactable.downloadDataCSV('%s', 'county_hazard_metrics.csv')", tbl_id),
  style = "
    background: none;
    border: none;
    color: #0073e6;
    text-decoration: underline;
    cursor: pointer;
    font-size: 0.9em;
    float: right;
    margin-bottom: 5px;
  "
)

# Display table with download button
browsable(tagList(download_btn, rt))
```

```{r}
# Changing the system_type values to be more descriptive
public_water_max_long <- public_water_max_long |>
mutate(system_type = recode(system_type,
    "ADFSTC" = "Non-Community Water Supply (Adult Foster Care Provider)",
    "CHLCMP" = "Non-Community Water Supply (Children's Camp)",
    "DAYCARE" = "Non-Community Water Supply (Child Care Provider)",
    "INDUS" = "Non-Community Water Supply (Industry)",
    "MEDCAR" = "Non-Community Water Supply (Medical Care Provider)",
    "MOTEL" = "Non-Community Water Supply (Hotel or Motel)",
    "MUN" = "Community Water Supply (for example Municipal Supply, Apartment, Nursing Home, Prison, etc.)",
    "OFFICE" = "Office Building",
    "PARK" = "Park",
    "RESD" = "Residential",
    "SCH" = "School",
    "TRB" = "Tribal Lands"
  ))
```

### Sampled Systems
#### Hazard Index per System
```{r}
# Define main hazard analytes
hazard_analytes <- c("HFPODA", "PFNA", "PFBS", "PFHxS")

# Aggregate analyte-level hazard contributions by system
system_analytes <- public_water_max_long |>
  filter(
    Hazard_Index > 1,
    !is.na(analyte),
    analyte %in% hazard_analytes,
    !is.na(analyte_value),
    !is.na(system_name)
  ) |>
  mutate(
    system_name = tolower(system_name),
    analyte_hazard = case_when(
      analyte == "HFPODA" ~ analyte_value / 10,
      analyte == "PFNA"   ~ analyte_value / 10,
      analyte == "PFBS"   ~ analyte_value / 2000,
      analyte == "PFHxS"  ~ analyte_value / 10
    )
  ) |>
  group_by(system_name, analyte) |>
  summarise(
    total_hazard_analyte = sum(analyte_hazard, na.rm = TRUE),
    .groups = "drop"
  )

# Compute total hazard per system to identify top systems
system_total <- system_analytes |>
  group_by(system_name) |>
  summarise(
    total_hazard = sum(total_hazard_analyte, na.rm = TRUE),
    .groups = "drop"
  ) |>
  arrange(desc(total_hazard)) |>
  slice_head(n = 10)

# Filter analytes to top systems
system_analytes_top <- system_analytes |>
  filter(system_name %in% system_total$system_name) |>
  mutate(
    system_name = factor(system_name, levels = system_total$system_name)
  )

# Identify dominant analyte per system
dominant_per_system <- system_analytes_top |>
  group_by(system_name) |>
  slice_max(order_by = total_hazard_analyte, n = 1, with_ties = FALSE) |>
  ungroup() |>
  rename(dominant_analyte = analyte,
         dominant_hazard = total_hazard_analyte) |>
  select(system_name, dominant_analyte, dominant_hazard)

# Merge dominant info back for tooltip
system_analytes_top <- system_analytes_top |>
  left_join(dominant_per_system, by = "system_name")

# Create stacked hazard index contribution plot with tooltip showing only dominant analyte
p_system_hazard <- ggplot(
  system_analytes_top,
  aes(
    x = system_name,
    y = total_hazard_analyte,
    fill = analyte,
    text = paste(
      "<b>System:</b>", system_name,
      "<br><b>Dominant Analyte:</b>", dominant_analyte,
      "<br><b>Contribution:</b>", round(dominant_hazard, 2)
    )
  )
) +
  geom_col(width = 0.7, position = "stack") +
  scale_fill_viridis_d(option = "cividis", end = 0.9) +
  labs(
    title = "Hazard Index Decomposition for Top Systems",
    x = "System Name",
    y = "Hazard Index",
    fill = "Analyte",
    caption = "Data source: Michigan PFAS Action Response Team (MPART)"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.position = "right"
  )

# Convert to interactive Plotly chart with automatic hover
ggplotly(p_system_hazard, tooltip = "text") |>
  onRender(js_auto_hover) |>
  layout(
    hoverlabel = list(
      bgcolor = "lightyellow",
      font = list(color = "black", size = 12),
      bordercolor = "orange"
    )
  )

```
```{r}
# Prepare metrics table for top systems

# Define main hazard analytes
hazard_analytes <- c("HFPODA", "PFNA", "PFBS", "PFHxS")

# Aggregate analyte-level hazard contributions per system
system_analytes <- public_water_max_long |>
  filter(
    Hazard_Index > 1,
    !is.na(analyte),
    analyte %in% hazard_analytes,
    !is.na(analyte_value),
    !is.na(system_name)
  ) |>
  mutate(
    analyte_hazard = case_when(
      analyte == "HFPODA" ~ analyte_value / 10,
      analyte == "PFNA"   ~ analyte_value / 10,
      analyte == "PFBS"   ~ analyte_value / 2000,
      analyte == "PFHxS"  ~ analyte_value / 10
    )
  ) |>
  group_by(system_name, analyte) |>
  summarise(
    total_hazard_analyte = sum(analyte_hazard, na.rm = TRUE),
    n_sites = n_distinct(hex_id),
    .groups = "drop"
  )

# Compute total hazard per system to identify top systems
system_total <- system_analytes |>
  group_by(system_name) |>
  summarise(
    total_hazard = sum(total_hazard_analyte, na.rm = TRUE),
    .groups = "drop"
  ) |>
  arrange(desc(total_hazard)) |>
  slice_head(n = 10)

# Identify dominant analyte per system
dominant_per_system <- system_analytes |>
  filter(system_name %in% system_total$system_name) |>
  group_by(system_name) |>
  slice_max(order_by = total_hazard_analyte, n = 1, with_ties = FALSE) |>
  ungroup() |>
  rename(
    `Dominant Analyte` = analyte,
    `Dominant Contribution` = total_hazard_analyte
  ) |>
  select(system_name, `Dominant Analyte`, `Dominant Contribution`)

# Prepare metrics table
metrics_table <- system_total |>
  filter(system_name %in% system_total$system_name) |>
  left_join(dominant_per_system, by = "system_name") |>
  left_join(
    system_analytes |>
      pivot_wider(
        names_from = analyte,
        values_from = total_hazard_analyte,
        values_fill = 0
      ) |>
      select(system_name, all_of(hazard_analytes)),
    by = "system_name"
  ) |>
  rename(System = system_name, `Total Hazard Index` = total_hazard) |>
  arrange(desc(`Total Hazard Index`))

# -------------------------------
# Render interactive table using reactable
tbl_id <- "system_hazard_metrics_table"

rt <- reactable(
  metrics_table,
  elementId = tbl_id,
  columns = list(
    System = colDef(name = "SYSTEM"),
    `Dominant Analyte` = colDef(name = "DOMINANT ANALYTE"),
    `Dominant Contribution` = colDef(name = "DOMINANT CONTRIBUTION"),
    `Total Hazard Index` = colDef(name = "TOTAL HAZARD INDEX"),
    HFPODA = colDef(name = "HFPODA"),
    PFNA = colDef(name = "PFNA"),
    PFBS = colDef(name = "PFBS"),
    PFHxS = colDef(name = "PFHxS")
  ),
  searchable = TRUE,
  filterable = TRUE,
  showPageSizeOptions = TRUE,
  defaultPageSize = 10,
  highlight = TRUE,
  bordered = TRUE,
  striped = TRUE
)

# Download button
download_btn <- tags$button(
  "Download CSV",
  onclick = sprintf("Reactable.downloadDataCSV('%s', 'system_hazard_metrics.csv')", tbl_id),
  style = "
    background: none;
    border: none;
    color: #0073e6;
    text-decoration: underline;
    cursor: pointer;
    font-size: 0.9em;
    float: right;
    margin-bottom: 5px;
  "
)

# Display table with download button
browsable(tagList(download_btn, rt))

```

### System Types
#### System Type Composition and decomposed contribution

```{r}
# Aggregate hazard contributions by system type
system_analytes_top <- public_water_max_long |>
  filter(
    Hazard_Index > 1,
    !is.na(analyte),
    analyte %in% hazard_analytes,
    !is.na(system_short)
  ) |>
  mutate(
    analyte_hazard = case_when(
      analyte == "HFPODA" ~ analyte_value / 10,
      analyte == "PFNA"   ~ analyte_value / 10,
      analyte == "PFBS"   ~ analyte_value / 2000,
      analyte == "PFHxS"  ~ analyte_value / 10
    )
  ) |>
  group_by(system_short, analyte) |>
  summarise(
    total_hazard_analyte = sum(analyte_hazard, na.rm = TRUE),
    .groups = "drop"
  )

# Compute total hazard per system_short (ALL system types)
system_total <- system_analytes_top |>
  group_by(system_short) |>
  summarise(total_hazard = sum(total_hazard_analyte, na.rm = TRUE), .groups = "drop") |>
  arrange(desc(total_hazard))

# Keep ALL system types (no filtering)
system_analytes_top <- system_analytes_top |>
  mutate(system_short = factor(system_short, levels = system_total$system_short))

# Compute dominant analyte per system_short
dominant_per_system <- system_analytes_top |>
  group_by(system_short) |>
  slice_max(order_by = total_hazard_analyte, n = 1, with_ties = FALSE) |>
  ungroup() |>
  rename(
    dominant_analyte = analyte,
    dominant_hazard = total_hazard_analyte
  ) |>
  select(system_short, dominant_analyte, dominant_hazard)

# Merge dominant info back
system_analytes_top <- system_analytes_top |>
  left_join(dominant_per_system, by = "system_short")

# Plot ALL system types
p_system_hazard <- ggplot(
  system_analytes_top,
  aes(
    x = system_short,
    y = total_hazard_analyte,
    fill = analyte,
    text = paste("<br><b>System Type:</b>", system_short,
      "<br><b>Dominant Analyte:</b>", dominant_analyte,
      "<br><b>Contribution:</b>", round(dominant_hazard, 2)
    )
  )
) +
  geom_col(width = 0.7, position = "stack") +
  scale_fill_viridis_d(option = "cividis", end = 0.9) +
  labs(
    title = "Hazard Index Decomposition by System Type",
    x = "System Type",
    y = "Hazard Index",
    fill = "Analyte"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.position = "right"
  )

ggplotly(p_system_hazard, tooltip = "text") |>
  onRender(js_auto_hover)


```


```{r}
# Step 1â€“5: Prepare the system hazard summary table
system_analytes_top <- public_water_max_long %>%
  filter(
    Hazard_Index > 1,
    !is.na(analyte),
    analyte %in% hazard_analytes,
    !is.na(system_short)
  ) %>%
  mutate(
    analyte_hazard = case_when(
      analyte == "HFPODA" ~ analyte_value / 10,
      analyte == "PFNA"   ~ analyte_value / 10,
      analyte == "PFBS"   ~ analyte_value / 2000,
      analyte == "PFHxS"  ~ analyte_value / 10
    )
  ) %>%
  group_by(system_short, analyte) %>%
  summarise(total_hazard_analyte = sum(analyte_hazard, na.rm = TRUE), .groups = "drop")

system_total <- system_analytes_top %>%
  group_by(system_short) %>%
  summarise(total_hazard = sum(total_hazard_analyte, na.rm = TRUE), .groups = "drop") %>%
  arrange(desc(total_hazard)) %>%
  slice_head(n = 15)

system_analytes_top <- system_analytes_top %>%
  filter(system_short %in% system_total$system_short)

dominant_per_system <- system_analytes_top %>%
  group_by(system_short) %>%
  slice_max(order_by = total_hazard_analyte, n = 1, with_ties = FALSE) %>%
  ungroup() %>%
  rename(
    dominant_analyte = analyte,
    dominant_hazard = total_hazard_analyte
  ) %>%
  select(system_short, dominant_analyte, dominant_hazard)

system_hazard_agg <- system_total %>%
  left_join(dominant_per_system, by = "system_short") %>%
  left_join(system_type_map %>% select(short_name, full_name),
            by = c("system_short" = "short_name")) %>%
  mutate(across(where(is.numeric), ~ round(.x, 2))) %>%
  arrange(desc(total_hazard))

# Step 6: Create reactable table only (no plot)
tbl_id <- "system_summary_table"

rt_system_summary <- reactable(
  system_hazard_agg,
  elementId = tbl_id,
  searchable = TRUE,
  filterable = TRUE,
  showPageSizeOptions = TRUE,
  defaultPageSize = 10,
  highlight = TRUE,
  bordered = TRUE,
  striped = TRUE,
  columns = list(
    full_name = colDef(name = "FULL DESCRIPTIVE NAME"),
    system_short = colDef(name = "SHORT NAME"),
    total_hazard = colDef(name = "TOTAL HAZARD"),
    dominant_analyte = colDef(name = "DOMINANT ANALYTE"),
    dominant_hazard = colDef(name = "DOMINANT HAZARD")
  )
)

# Step 7: Download button
download_btn <- tags$button(
  "Download CSV",
  onclick = sprintf("Reactable.downloadDataCSV('%s', 'system_summary.csv')", tbl_id),
  style = "
    background: none;
    border: none;
    color: #0073e6;
    text-decoration: underline;
    cursor: pointer;
    font-size: 0.9em;
    float: right;
    margin-bottom: 5px;
  "
)

# Display the table with download button
browsable(tagList(download_btn, rt_system_summary))

```
### Systems' Map
#### Map showing the locations of different system types
```{r}
# Extract system locations from public_water_max_long
system_locations <- public_water_max_long |>
  filter(
    Hazard_Index > 1,
    !is.na(system_short)
  ) |>
  distinct(
    hex_id, system_name, system_short,
    Hazard_Index, longitude, latitude
  )

# Add dominant analyte info
system_locations <- system_locations |>
  left_join(dominant_per_system, by = "system_short") |>
  mutate(
    popup_label = paste0(
      "<b>System Name:</b> ", system_name, "<br>",
      "<b>System Type:</b> ", system_short, "<br>",
      "<b>Hazard Index:</b> ", round(Hazard_Index, 2), "<br>",
      "<b>Dominant Analyte:</b> ", dominant_analyte, "<br>",
      "<b>Contribution:</b> ", round(dominant_hazard, 2)
    )
  )

# Crosstalk SharedData
sd_systems <- SharedData$new(system_locations, key = ~hex_id, group = "systems")

# Load Michigan counties
mi_counties <- st_read("GeoFiles/cb_2018_us_county_500k.shp", quiet = TRUE) |>
  filter(STATEFP == "26") |>
  st_transform(4326)

# Color palette for ALL system types
pal_sys <- colorFactor("viridis", system_locations$system_short)

# Crosstalk filter UI
filter_ui <- filter_select(
  id = "system_filter",
  label = "Filter by System Type",
  sharedData = sd_systems,
  group = ~system_short
)

# Build the map (reactive to Crosstalk)
map_widget <- leaflet(sd_systems) %>%
  setView(lng = -84.5, lat = 44.5, zoom = 6) %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addPolygons(
    data = mi_counties,
    fillColor = "grey",
    color = "black",
    weight = 1,
    fillOpacity = 0.3
  ) %>%
  addCircleMarkers(
    lng = ~longitude,
    lat = ~latitude,
    radius = ~sqrt(Hazard_Index) * 2,
    fillColor = ~pal_sys(system_short),
    color = "black",
    fillOpacity = 0.8,
    stroke = TRUE,
    weight = 0.5,
    popup = ~popup_label,
    label = ~lapply(popup_label, htmltools::HTML)
  ) %>%
  addLegend(
    pal = pal_sys,
    values = system_locations$system_short,
    title = "System Type",
    position = "topright"
  )

# Display filter ABOVE the map (best for dashboards)
tagList(
  div(style = "margin-bottom: 10px;", filter_ui),
  div(style = "width: 100%;", map_widget)
)

```

```{r}
# Build metrics table from system_locations
metrics_table <- system_locations |>
  group_by(system_short) |>
  summarise(
    n_systems = n(),                                 # number of systems of this type
    mean_hazard = mean(Hazard_Index, na.rm = TRUE),  # average hazard
    total_hazard = sum(Hazard_Index, na.rm = TRUE),  # total hazard
    dominant_analyte = first(dominant_analyte),      # from your join
    dominant_hazard = first(dominant_hazard),        # from your join
    .groups = "drop"
  ) |>
  # Join full descriptive name
  left_join(
    system_type_map %>% select(short_name, full_name),
    by = c("system_short" = "short_name")
  ) |>
  arrange(desc(n_systems)) |>
  mutate(
    mean_hazard = round(mean_hazard, 2),
    total_hazard = round(total_hazard, 2),
    dominant_hazard = round(dominant_hazard, 2)
  )

# Assign table ID for download
tbl_id <- "system_metrics_table"

# Build reactable
rt_system_metrics <- reactable(
  metrics_table,
  elementId = tbl_id,
  searchable = TRUE,
  filterable = TRUE,
  highlight = TRUE,
  bordered = TRUE,
  striped = TRUE,
  defaultPageSize = 10,
  columns = list(
    full_name = colDef(name = "Full Descriptive Name"),
    system_short = colDef(name = "Short Name"),
    n_systems = colDef(name = "Number of Systems"),
    mean_hazard = colDef(name = "Mean Hazard Index"),
    total_hazard = colDef(name = "Total Hazard Index"),
    dominant_analyte = colDef(name = "Dominant Analyte"),
    dominant_hazard = colDef(name = "Dominant Analyte Contribution")
  )
)

# Download button
download_btn <- tags$button(
  "Download CSV",
  onclick = sprintf("Reactable.downloadDataCSV('%s', 'system_metrics_table.csv')", tbl_id),
  style = "
    background: none;
    border: none;
    color: #0073e6;
    text-decoration: underline;
    cursor: pointer;
    font-size: 0.9em;
    float: right;
    margin-bottom: 5px;
  "
)

# Display table with download button
browsable(tagList(download_btn, rt_system_metrics))


```

### Site Type Analysis
#### Mean Hazard Index per Site
```{r, include=FALSE}
hazard_data_types <- merged_data |>
  mutate(
    type = str_replace_all(type, "mlitary", "military"),
    type = str_to_title(type),
    type = str_replace_all(type, "Laundromat/Drycleaner", "Laundromat/Dry Cleaner"),
    type = case_when(type %in% c("Tannery", "Unknown", 
                                 "Refinery", "Fire Station") ~ "Other",
                     TRUE ~ type)
  ) |>
  filter(Hazard_Index > 1, !is.na(type)) |>
  distinct(hex_id, type, Hazard_Index)

mean_by_type <- hazard_data_types |>
  group_by(type) |>
  summarise(
    mean_hazard = mean(Hazard_Index, na.rm = TRUE),
    n_sites = n(),
    .groups = "drop"
  )

top_types <- mean_by_type |>
  arrange(desc(mean_hazard)) |>
  slice_head(n = 15)

plot_data <- mean_by_type |>
  filter(type %in% top_types$type) |>
  mutate(type = factor(type, levels = top_types$type))

p <- ggplot(plot_data, aes(
  x = type, 
  y = mean_hazard, 
  fill = type,
  text = paste("<br><b>Site Type:</b>", type,
               "<br><b>Mean Hazard Index:</b>", round(mean_hazard, 2),
               "<br><b>Number of Sites:</b>", n_sites)
)) +
  geom_col(position = position_dodge(width = 0.7), width = 0.7) +
  scale_fill_viridis_d(option = "cividis") +
  labs(
    title = "Mean Hazard Index by Site Type (Hazard_Index > 1)",
    x = "Site Type",
    y = "Mean Hazard Index (ppt)",
    fill = "Site Type",
    caption = "Data source: Michigan PFAS Action Response Team (MPART)"
  ) +
  theme_minimal() +
  theme(
    legend.position = "none",
    axis.text.x = element_text(angle = 45, hjust = 1)
  )

ggplotly(p, tooltip = "text") |>
  onRender("
    function(el) {
      var totalPoints = el.data[0].x.length;
      var i = 0;
      setInterval(function() {
        Plotly.Fx.hover(el, [{ curveNumber: 0, pointNumber: i }], 'xy');
        i = (i + 1) % totalPoints;
      }, 2000);
    }
  ")

```

```{r}
# Convert pfas_sites to sf and clean type
pfas_sites_sf <- pfas_sites %>%
  mutate(
    type = str_replace_all(type, "mlitary", "military"),
    type = str_to_title(type),
    type = str_replace_all(type, "Laundromat/Drycleaner", "Laundromat/Dry Cleaner"),
    type = case_when(
      type %in% c("Tannery", "Unknown", "Refinery", "Fire Station") ~ "Other",
      TRUE ~ type
    ),
    popup_label = paste0(
      "<b>Facility:</b> ", facility, "<br>",
      "<b>Type:</b> ", type, "<br>",
      "<b>County:</b> ", county
    )
  )

# Crosstalk SharedData
sd_sites <- SharedData$new(pfas_sites_sf, key = ~facility, group = "pfas")

# Load Michigan counties shapefile
mi_counties <- st_read("GeoFiles/cb_2018_us_county_500k.shp", quiet = TRUE) %>%
  filter(STATEFP == "26") %>%
  st_transform(4326)

# Viridis palette
pal <- colorFactor("viridis", pfas_sites_sf$type)

# Crosstalk filter UI (placed ABOVE map)
filter_ui <- filter_select(
  id = "type_filter",
  label = "Search by Site Type",
  sharedData = sd_sites,
  group = ~type
)

# Leaflet map (full width)
map <- leaflet(sd_sites) %>%
  setView(lng = -84.5, lat = 44.5, zoom = 5.5) %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addPolygons(
    data = mi_counties,
    fillColor = "grey",
    color = "black",
    weight = 1,
    fillOpacity = 0.3
  ) %>%
  addCircleMarkers(
    lng = ~longitude, lat = ~latitude,
    radius = 4,
    fillColor = ~pal(type),
    stroke = FALSE,
    fillOpacity = 0.8,
    popup = ~popup_label,
    label = ~lapply(popup_label, htmltools::HTML)
  ) %>%
  addLegendFactor(
    pal = pal,
    values = pfas_sites_sf$type,
    title = "Contamination Site Type",
    position = "topright",
    shape = "circle",
    width = 8,
    height = 8,
    fillOpacity = 0.8
  )

# Display filter ABOVE map (full width)
tagList(
  div(style = "margin-bottom: 10px;", filter_ui),
  div(style = "width: 100%;", map)
)

```

```{r}
# Visualizing the type of site by the composition of 4 main analytes with the hazard index

# Use the already-cleaned hazard_data_types to get clean type values
# Join back to merged_data to restore analyte columns
hazard_data_analytes <- merged_data |>
  inner_join(
    hazard_data_types |> select(hex_id, type, Hazard_Index),
    by = c("hex_id", "type", "Hazard_Index")
  ) |>
  distinct(hex_id, type, analyte, analyte_value, Hazard_Index) |>
  filter(analyte %in% hazard_analytes)

# Summarize total hazard and analyte sums by type
hazard_summary_by_type <- hazard_data_analytes |>
  group_by(type, analyte) |>
  summarise(sum_analyte = sum(analyte_value, na.rm = TRUE), .groups = "drop") |>
  left_join(
    hazard_data_analytes |>
      group_by(type) |>
      summarise(
        total_hazard = sum(Hazard_Index, na.rm = TRUE),
        n_sites = n_distinct(hex_id),
        .groups = "drop"
      ),
    by = "type"
  ) |>
  pivot_wider(
    names_from = analyte,
    values_from = sum_analyte,
    values_fill = 0
  ) |>
  mutate(across(where(is.numeric), ~ round(.x, 2))) |>
  arrange(desc(total_hazard))

# Assign a unique ID for reactable
tbl_id <- "hazard_summary_table"

# Create the interactive table with custom headers
rt <- reactable(
  hazard_summary_by_type,
  elementId = tbl_id,
  searchable = TRUE,
  filterable = TRUE,
  showPageSizeOptions = TRUE,
  defaultPageSize = 10,
  highlight = TRUE,
  bordered = TRUE,
  striped = TRUE,
  columns = list(
    type = colDef(name = "TYPE"),
    total_hazard = colDef(name = "TOTAL HAZARD"),
    n_sites = colDef(name = "N SITES")
  )
)

# Create download link-style button in top-right
download_btn <- tags$button(
  "Download CSV",
  onclick = sprintf("Reactable.downloadDataCSV('%s', 'hazard_summary_by_type.csv')", tbl_id),
  style = "
    background: none;
    border: none;
    color: #0073e6;
    text-decoration: underline;
    cursor: pointer;
    font-size: 0.9em;
    float: right;
    margin-bottom: 5px;
  "
)

# Display table with download link above it
browsable(tagList(download_btn, rt))

```

### Surface Water
#### Analyte Concentration

```{r}
# Top 10 analyte category by total % & absolute concentration

# Prepare data
top10_analyte <- surface_max_full |>
  filter(analyte_value > 0) |>
  group_by(analyte) |>
  summarize(total_concentration = sum(analyte_value, na.rm = TRUE)) |>
  ungroup() |>
  mutate(share = total_concentration / sum(total_concentration)) |>
  slice_max(share, n = 10) |>
  arrange(share)

# Interactive Plotly bar chart
p_surface <- plot_ly(
  data = top10_analyte,
  x = ~share,
  y = ~fct_reorder(analyte, share),
  type = "bar",
  orientation = "h",
  marker = list(
    color = ~share,
    colorscale = "Cividis"
  ),
  text = ~paste0(
    percent(share, accuracy = 0.1),
    " (", comma(round(total_concentration, 1)), " ppt)"
  ),
  textposition = "outside",
  hoverinfo = "text",
  hovertext = ~paste(
    "<b>Analyte:</b>", analyte,
    "<br><b>Share:</b>", percent(share, accuracy = 0.1),
    "<br><b>Total Concentration:</b>", comma(round(total_concentration, 1)), "ppt"
  )
) |>
  layout(
    title = "Top 10 PFAS Analytes in Surface Water",
    xaxis = list(
      title = "Share of Total PFAS",
      tickformat = ".0%",
      range = c(0, max(top10_analyte$share) * 1.25)
    ),
    yaxis = list(title = "Analyte Category"),
    margin = list(l = 120, r = 40, t = 80),
    hoverlabel = list(
      bgcolor = "lightyellow",
      font = list(color = "black", size = 12),
      bordercolor = "orange"
    ),
    showlegend = FALSE
  ) |>
  onRender(js_auto_hover)

p_surface

```


```{r}
# Load Michigan counties
mi_counties <- suppressMessages(
  st_read("cb_2018_us_county_500k.shp", quiet = TRUE)
) |>
  filter(STATEFP == "26") |>
  st_transform(4326)

# Aggregate surface water PFAS by county
surface_county_map <- surface_max_full |>
  group_by(geoid) |>
  summarize(total_value = sum(analyte_value, na.rm = TRUE), .groups = "drop") |>
  left_join(mi_counties, by = c("geoid" = "GEOID")) |>
  st_as_sf()

# SharedData for Crosstalk filtering
shared_surface <- SharedData$new(surface_county_map, key = ~geoid, group = "surface")

# Color palette
pal <- colorNumeric("magma", domain = surface_county_map$total_value)

# Filter widget (placed above the map)
filter_widget <- filter_select(
  id = "county_filter",
  label = "Filter by County",
  sharedData = shared_surface,
  group = ~NAME
)

# Build full-width interactive map
map_widget <- leaflet(shared_surface) %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addPolygons(
    fillColor = ~pal(total_value),
    fillOpacity = 0.8,
    color = "white",
    weight = 1,
    label = ~paste0(
      "<b>", NAME, " County</b><br>",
      "Total PFAS: ", round(total_value, 1), " ppt"
    ) |> lapply(htmltools::HTML),
    highlightOptions = highlightOptions(
      weight = 2,
      color = "black",
      fillOpacity = 0.9,
      bringToFront = TRUE
    )
  ) %>%
  addLegend(
    pal = pal,
    values = ~total_value,
    title = "Total PFAS (ppt)",
    position = "bottomright"
  )

# Display filter above full-width map
htmltools::tagList(
  filter_widget,
  map_widget
)

```



### Public Water Conc.
#### Top 10 public water PFAS Conc.
```{r}
hazard_colors <- c("HFPODA" = "#575c6d", "PFNA" = "#a69d75", "PFBS" = "#ffea47", "PFHxS" = "#00204d")

# Top 10 PFAS analytes in public water
top_analytes <- public_max_full |>
  filter(analyte_value > 0) |>
  group_by(analyte) |>
  summarize(total_concentration = sum(analyte_value, na.rm = TRUE), .groups = "drop") |>
  slice_max(total_concentration, n = 10)

other_analytes <- top_analytes$analyte[which(!(top_analytes$analyte %in% names(hazard_colors)))]
other_colors <- setNames(rep("pink", length(other_analytes)), other_analytes)

ggplot(top_analytes, aes(x = fct_reorder(analyte, total_concentration), 
                         y = total_concentration, 
                         fill = analyte)) +
  geom_col() +
  geom_text(aes(label = comma(round(total_concentration, 1))), 
            hjust = -0.05, size = 3.5) +  # labels outside bars
  coord_flip() +
#  scale_fill_viridis_c(option = "cividis", direction = -1) +
  scale_fill_manual(values = c(hazard_colors, other_colors)) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 20)) +  # wrap long names
  labs(
    title = "Top 10 PFAS Analytes in Public Water Systems",
    x = "PFAS Analyte",
    y = "Total PFAS Concentration (ppt)",
    fill = "Total Concentration",
    caption = "Data source: Michigan PFAS Action Response Team (MPART), EGLE"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    plot.title = element_text(face = "bold", size = 16),
    axis.title = element_text(face = "bold"),
    legend.position = "none"
  ) +
  expand_limits(y = max(top_analytes$total_concentration) * 1.1)  # space for labels
```

```{r}
# Map of total public water PFAS by county
public_county_map <- public_max_full |>
  group_by(geoid) |>
  summarize(total_value = sum(analyte_value, na.rm = TRUE), .groups = "drop") |>
  left_join(mi_counties, by = c("geoid" = "GEOID")) |>
  st_as_sf()

ggplot(public_county_map) +
  geom_sf(aes(fill = total_value), color = "white") +
  scale_fill_viridis_c(option = "magma", na.value = "grey90") +
  labs(
    title = "Total PFAS Concentration in Public Water by County",
    x = "Longitude",
    y = "Latitude",
    fill = "Total PFAS (ppt)",
    caption = "Data source: Michigan PFAS Action Response Team (MPART), EGLE"
  ) +
  theme_minimal()

```


### Combined Conc. Analysis
#### Top 10 Counties Metrics

```{r, warning=FALSE}
library(tidytext)

# Read county shapefile
counties_sf <- suppressMessages(suppressWarnings(st_read("cb_2018_us_county_500k.shp", quiet =TRUE))) |>
  st_drop_geometry() |>
  select(GEOID, NAME)

# Convert GEOID to character for joining
pfas_sites_conc <- pfas_sites_conc |> mutate(geoid = as.character(geoid))
surface_max_full <- surface_max_full |> mutate(geoid = as.character(geoid))
public_max_full <- public_max_full |> mutate(geoid = as.character(geoid))

# Aggregate total PFAS per county
surface_county_totals <- surface_max_full |>
  group_by(geoid) |>
  summarize(total_surface = sum(analyte_value, na.rm = TRUE), .groups = "drop")

public_county_totals <- public_max_full |>
  group_by(geoid) |>
  summarize(total_public = sum(analyte_value, na.rm = TRUE), .groups = "drop")

# Count sites per county
sites_county <- pfas_sites_conc |>
  count(geoid) |>
  rename(n_sites = n)

# Combine totals by county
county_summary <- surface_county_totals |>
  full_join(public_county_totals, by = "geoid") |>
  full_join(sites_county, by = "geoid") |>
  left_join(counties_sf, by = c("geoid" = "GEOID")) |>
  relocate(NAME, .before = geoid) |>
  select(NAME, total_surface, total_public, n_sites)

# Flextable for top 10 counties by total_surface
top10_county_table <- county_summary |> slice_max(total_surface, n = 10)
flextable(top10_county_table) |> autofit()

# Pivot longer for faceted bar plot
county_long <- top10_county_table |>
  pivot_longer(cols = c(total_surface, total_public, n_sites),
               names_to = "metric", values_to = "value") |>
  mutate(NAME = reorder_within(NAME, value, metric))  # reorder within facet

# Custom labels for facets
metric_labels <- c(
  total_surface = "Total Surface PFAS (ng/L)",
  total_public = "Total Public PFAS (ng/L)",
  n_sites = "Number of PFAS Sites"
)
```


```{r}
# Total PFAS concentration by water type
total_pfas <- bind_rows(
  surface_max_full |> summarize(total = sum(analyte_value, na.rm = TRUE)) |> mutate(water_type = "Surface Water"),
  public_max_full  |> summarize(total = sum(analyte_value, na.rm = TRUE)) |> mutate(water_type = "Public Water")
) |> 
  mutate(pct = total / sum(total) * 100,
         lbl = paste0(water_type, " (", round(pct, 1), "%)"))

# Pie chart
total_pfas |>
  ggplot(aes(x = "", y = total, fill = water_type)) +
  geom_col(width = 1, color = "white") +
  coord_polar(theta = "y") +
  geom_text(aes(label = lbl), position = position_stack(vjust = 0.5), size = 5) +
  scale_fill_manual(values = c("Surface Water" = "mediumseagreen", "Public Water" = "tomato")) +
  labs(title = "Total PFAS Concentration by Water Type",
       caption = "Data source: Michigan PFAS Action Response Team (MPART), EGLE") +
  theme_void() +
  theme(plot.title = element_text(face = "bold", size = 16),
        plot.caption = element_text(face = "bold"))

```

