---
title: "Public Water Hazard Index Analysis"
format:
  dashboard:
    orientation: columns  
    theme: flatly            
    toc: true              
    self-contained: true   
execute:
  echo: false
  warning: false
  message: false
  output: true
---

```{r}
#| include: false
set.seed(1994)

# Loading necessary packages
library(tidyverse)
library(naniar)
library(janitor)
library(sf)
library(gt)
library(skimr)
library(tidycensus)
library(maps)
library(patchwork)
library(ggrepel)
library(ggthemes)
library(scales)
library(reshape2)
library(ggcorrplot)
library(flextable)
library(dplyr)
library(tidyr)
library(plotly)
library(leaflet)
library(reactable)
library(reactablefmtr)
library(htmltools)
library(leaflet.extras2)
library(leaflegend)
library(htmlwidgets)
library(leaflet.extras)
library(crosstalk)
library(stringr)



# Function for creating data dictionary
data_dictionary <- function(myData, descripts) {
tibble(Variable = colnames(myData),
       Type = map_chr(myData, .f = function(x){typeof(x)[1]}),
       Description = descripts) |> 
  gt()
}
```

```{r PFAS_packages}
#| eval: true
#| include: false

# Create function to add geoid variable given longitude and latitude for county-level data
add_geoid <- function(my_data) {
  # Create sf object to help add geoid column
my_data_sf <- my_data |> 
st_as_sf(coords = c("longitude", "latitude"))

# Set coordinate reference system (CRS) to match counties data
counties <- st_read("GeoFiles//cb_2018_us_county_500k.shp")
st_crs(my_data_sf) <- st_crs(counties)

ret_data <- my_data_sf |> 
  st_join(counties) |> 
    mutate(longitude = st_coordinates(geometry)[, 1],
           latitude = st_coordinates(geometry)[, 2]) |> 
  st_drop_geometry() |> 
  as_tibble() |> 
  dplyr::select(GEOID, longitude, latitude) |> 
  dplyr::rename(geoid = GEOID) |> 
  distinct() |> 
  right_join(my_data)

return(ret_data)
}
```


```{r PFAS_surface_clean}
#| eval: true
#| include: false

# Importing data on PFAS levels in surface water in Michigan
analyte_info <- read_csv("PFAS_Surface_Water_Sampling.csv") |> 
              dplyr::select(-c(X:Latitude, GlobalID, OBJECTID,
                               ends_with("Flag")))

surface_water <- read_csv("PFAS_Surface_Water_Sampling.csv") |> 
  clean_names() |> 
  dplyr::select(-ends_with("_flag")) |> 
  dplyr::select(-c(cas307244_pf_hx_a:cas919005144_adona_rl)) |> 
  bind_cols(analyte_info)

# Importing data on surface water data dictionary
surface_water_dictionary <- read_csv("surface_water_data_dictionary.csv")

# Creating long version of surface water data
surface_water_long <- surface_water |> 
  dplyr::rename(object_id = objectid) |> 
  dplyr::select(longitude, latitude, object_id, everything(), 
                -c(x:y), -ends_with("Flag"), -global_id) |> 
  pivot_longer(cols = colnames(analyte_info), 
               names_to = "analyte", 
               values_to = "analyte_value") |> 
  dplyr::select(-matrix, -unit, -object_id) |> 
  add_geoid()

# Saving to external CSV
write_csv(surface_water_long, file = "pfas_surface_water_long.csv")
```


```{r PFAS_public_clean}
#| eval: true
#| include: false

# Importing shape file data for public water supply PFAS levels data
public_water_shape <- st_read("Public_Water_Supply_Sampling_Hexbins_and_Results/Public_Water_Supply_Sampling_Hexbins.shp") |> 
  mutate(centroid = st_centroid(geometry),
         longitude = st_coordinates(centroid)[, 1],
         latitude = st_coordinates(centroid)[, 2]) |> 
  dplyr::select(HexID, longitude, latitude) |> 
  st_drop_geometry() |> 
  as_tibble()

# Importing data on public water supply PFAS levels
public_water <- read_csv("Public_Water_Supply_Sampling_Hexbins_and_Results.csv")

# Adding geoid, longitude, and latitude information to public water data
# and cleaning variable names
public_water_wide <- public_water |> 
  left_join(public_water_shape, by = "HexID") |> 
  dplyr::select(-ends_with(c("Result", "Flags"))) |> 
  clean_names() |> 
  dplyr::rename(object_id = objectid) |> 
  dplyr::select(object_id:sys_loc_code, longitude, latitude, everything()) |> 
  bind_cols(dplyr::select(public_water, ends_with("Result"))) |> 
  add_geoid()

# Pivoting public water data from wide to long format
public_water_long <- public_water_wide |> 
  pivot_longer(cols = c(ends_with(c("Result"))), 
               names_to = "analyte", 
               values_to = "analyte_value") |> 
  mutate(analyte = gsub(analyte, pattern = "Result", replacement = "")) |> 
  dplyr::select(-c(hex_id, 
                   wssn, loc_name:sys_loc_code, 
                   phase_code:task_type,
                   treatment_status:sys_sample_code,
                   lab_number:lab_sdg, 
                   object_id, position_source,
                   analytical_method,
                   sampling_results_count)) |> 
  mutate(system_type = fct_recode(system_type,
                               "Non-Community Water Supply (Adult Foster Care Provider)" = "ADFSTC",
                               "Non-Community Water Supply (Children's Camp)" = "CHLCMP",
                               "Non-Community Water Supply (Child Care Provider)" = "DAYCARE",
                               "Non-Community Water Supply (Industry)" = "INDUS",
                               "Non-Community Water Supply (Medical Care Provider)" = "MEDCAR",
                               "Non-Community Water Supply (Hotel or Motel)" = "MOTEL",
                               "Community Water Supply (for example Municipal Supply, Apartment, Nursing Home, Prison, etc.)" = "MUN",
                               "Office Building" = "OFFICE",
                               "Park" = "PARK",
                               "Residential" = "RESD",
                               "School" = "SCH",
                               "Tribal Lands" = "TRB"))


# Saving to external CSV
write_csv(public_water_long, file = "pfas_public_water_long.csv")
```


```{r PFAS_sites_import}
#| eval: true
#| include: false

pfas_site_path <- "pfas_sites.csv"

if(file.exists(pfas_site_path) == FALSE) {
# Importing data on identified sites from https://www.michigan.gov/pfasresponse
# Downloaded on 02/25/2025
pfas_sites <- read_csv("Michigan_PFAS_Sites.csv") |> 
  janitor::clean_names() |> 
  dplyr::select(facility:site_type, location:military, facility_date, site_background:anticipated_activities, -tier, -site_type) |> 
  add_geoid()

# Saving cleaned data
write_csv(pfas_sites, file = pfas_site_path)
} else {
  # Importing
  pfas_sites <- read_csv(pfas_site_path)
}
```

```{r}
# Drop flag columns, replace NA in PFAS Result columns with 0, and ensure numeric
public_water_wide <- public_water_wide |> 
  select(-ends_with("Flags")) |> 
  mutate(across(ends_with("Result"), ~replace_na(as.numeric(.x), 0)))

# Calculating the hazard index
public_water_wide <- public_water_wide |>
  mutate(Hazard_Index = (HFPODAResult / 10) +
         (PFNAResult / 10) +
         (PFBSResult / 2000) +
         (PFHxSResult / 10))
```


```{r}
# Displaying the high index areas with the highest analyte contributor in a table
high_hazard <- public_water_wide |> 
  filter(Hazard_Index > 1) |> 
  select(hex_id, sample_date, Hazard_Index, HFPODAResult, PFNAResult, PFBSResult, PFHxSResult) |> 
  arrange(desc(Hazard_Index)) |> 
  flextable() |> 
  set_caption("Public Water Locations with Hazard Index > 1") |> 
  autofit()
```

```{r}
# Extracting the maximum hazard per hex ID
public_water_max <- public_water_wide |> 
  group_by(hex_id) |> 
  slice_max(order_by = Hazard_Index, n = 1, with_ties = FALSE) |> 
  ungroup()
```


```{r}
# Changing the wide format to long format
public_water_max_long <- public_water_max |>
pivot_longer(cols = ends_with("Result"),   
               names_to = "analyte",
               values_to = "analyte_value") |>
mutate(analyte = gsub("Result$", "", analyte))
```


```{r}
merged_data <- public_water_max_long |>
  left_join(
    pfas_sites |> mutate(geoid = as.character(geoid)), 
    by = "geoid",
    relationship = "many-to-many"
  )
```

```{r}
# Reusable JS for auto-hover
js_auto_hover <- "
function(el, x) {
  var totalPoints = el.data[0].x.length;
  var i = 0;
  setInterval(function() {
    Plotly.Fx.hover(el, [{ curveNumber: 0, pointNumber: i }]);
    i = (i + 1) % totalPoints;
  }, 2000);
}
"
```

```{r}
# Reusable JS for auto-hover on pie charts
js_auto_hover_pie <- "
function(el, x) {
  var totalSlices = el.data[0].labels.length; // number of pie slices
  var i = 0;
  setInterval(function() {
    Plotly.Fx.hover(el, [{ curveNumber: 0, pointNumber: i }]);
    i = (i + 1) % totalSlices;
  }, 2000);
}
"
```

```{r}
# Prepare system type mapping
system_type_map <- tibble(
  short_name = c(
    "ADFSTC", "CHLCMP", "DAYCARE", "INDUS", "MEDCAR",
    "MOTEL", "MUN", "OFFICE", "PARK", "RESD", "SCH", "TRB"
  ),
  full_name = c(
    "Non-Community Water Supply (Adult Foster Care Provider)",
    "Non-Community Water Supply (Children's Camp)",
    "Non-Community Water Supply (Child Care Provider)",
    "Non-Community Water Supply (Industry)",
    "Non-Community Water Supply (Medical Care Provider)",
    "Non-Community Water Supply (Hotel or Motel)",
    "Community Water Supply (for example Municipal Supply, Apartment, Nursing Home, Prison, etc.)",
    "Office Building",
    "Park",
    "Residential",
    "School",
    "Tribal Lands"
  )
)

# Apply short names to the dataset
public_water_max_long <- public_water_max_long |>
  mutate(system_short = recode(system_type,
    "Non-Community Water Supply (Adult Foster Care Provider)" = "ADFSTC",
    "Non-Community Water Supply (Children's Camp)" = "CHLCMP",
    "Non-Community Water Supply (Child Care Provider)" = "DAYCARE",
    "Non-Community Water Supply (Industry)" = "INDUS",
    "Non-Community Water Supply (Medical Care Provider)" = "MEDCAR",
    "Non-Community Water Supply (Hotel or Motel)" = "MOTEL",
    "Community Water Supply (for example Municipal Supply, Apartment, Nursing Home, Prison, etc.)" = "MUN",
    "Office Building" = "OFFICE",
    "Park" = "PARK",
    "Residential" = "RESD",
    "School" = "SCH",
    "Tribal Lands" = "TRB"
  ))
```

## Hazard Index Analysis {.tabset}

### Total Hazard Composition
#### Analyte Composition
```{r}
# Define main hazard analytes
hazard_analytes <- c("HFPODA", "PFNA", "PFBS", "PFHxS")

# Aggregate analyte-level hazard contributions across all hexes
total_analyte_hazard <- public_water_max_long |>
  filter(analyte %in% hazard_analytes) |>           
  mutate(analyte_hazard = case_when(
    analyte == "HFPODA" ~ analyte_value / 10,
    analyte == "PFNA"   ~ analyte_value / 10,
    analyte == "PFBS"   ~ analyte_value / 2000,
    analyte == "PFHxS"  ~ analyte_value / 10
  )) |>
  group_by(analyte) |>
  summarise(
    total_contribution = sum(analyte_hazard, na.rm = TRUE),
    .groups = "drop"
  ) |>
  arrange(desc(total_contribution)) |>
  mutate(
    percent = round(total_contribution / sum(total_contribution) * 100, 1),
    analyte = factor(analyte, levels = analyte)
  )

# JS for automatic hover (consistent with your other plots)
js_auto_hover <- "
function(el, x) {
  var totalBars = el.data[0].x.length;
  var i = 0;
  setInterval(function() {
    Plotly.Fx.hover(el, [{ curveNumber: 0, pointNumber: i }], 'xy');
    i = (i + 1) % totalBars;
  }, 2000);
}
"

# Extend y-axis to prevent clipped text
y_max <- max(total_analyte_hazard$total_contribution, na.rm = TRUE) * 1.15

# Create Plotly bar chart with cividis palette
p_bar <- plot_ly(
  data = total_analyte_hazard,
  x = ~analyte,
  y = ~total_contribution,
  type = "bar",
  color = ~analyte,
  colors = viridis::viridis(
    n = length(unique(total_analyte_hazard$analyte)),
    option = "cividis"
  ),
  text = ~paste0(percent, "%"),
  textposition = "outside",
  hoverinfo = "text",
  hovertext = ~paste(
    "<b>Analyte:</b>", analyte,
    "<br><b>Total Contribution:</b>", round(total_contribution, 2),
    "<br><b>Percent of Total:</b>", percent, "%"
  )
) |>
  layout(
    title = "Total Decomposed Hazard Index Contributions by Analyte",
    xaxis = list(title = "Analyte"),
    yaxis = list(
      title = "Total Hazard Index Contribution",
      range = c(0, y_max)
    ),
    showlegend = FALSE,
    margin = list(t = 80),
    hoverlabel = list(
      bgcolor = "lightyellow",
      font = list(color = "black", size = 12),
      bordercolor = "orange"
    )
  ) |>
  onRender(js_auto_hover)

p_bar
```

```{r}
# Define main hazard analytes
hazard_analytes <- c("HFPODA", "PFNA", "PFBS", "PFHxS")

# Load Michigan counties shapefile
mi_counties <- st_read("GeoFiles/cb_2018_us_county_500k.shp", quiet = TRUE) %>%
  filter(STATEFP == "26")

# Prepare analyte-wide data
analyte_wide <- public_water_max_long %>%
  filter(analyte %in% hazard_analytes) %>%
  select(hex_id, analyte, analyte_value) %>%
  pivot_wider(
    names_from = analyte,
    values_from = analyte_value,
    values_fill = 0
  )

# Prepare hazard sites
hazard_sites_full <- public_water_max_long %>%
  filter(Hazard_Index > 1) %>%
  distinct(hex_id, system_name, system_type, Hazard_Index, longitude, latitude) %>%
  rename(type = system_type) %>%
  left_join(analyte_wide, by = "hex_id") %>%
  st_as_sf(coords = c("longitude", "latitude"), crs = 4326) %>%
  mutate(Hazard_Index = as.numeric(Hazard_Index))

# Color palette
max_radius <- 20
hazard_pal <- colorNumeric(
  palette = "YlOrRd",
  domain = c(0, max(hazard_sites_full$Hazard_Index, na.rm = TRUE))
)

hazard_sites_full <- hazard_sites_full %>%
  mutate(scaled_radius = sqrt(Hazard_Index / max(Hazard_Index, na.rm = TRUE)) * max_radius)

# Popups
hazard_popup <- hazard_sites_full %>%
  mutate(popup = paste0(
    "<b>System Name:</b> ", system_name, "<br>",
    "<b>Type:</b> ", type, "<br>",
    "<b>Hazard Index:</b> ", round(Hazard_Index, 2), "<br>",
    "<b>HFPODA:</b> ", round(HFPODA, 2), "<br>",
    "<b>PFNA:</b> ", round(PFNA, 2), "<br>",
    "<b>PFBS:</b> ", round(PFBS, 2), "<br>",
    "<b>PFHxS:</b> ", round(PFHxS, 2)
  ))

# Legend values (just 3 representative bubbles)
legend_values <- c(0.25, 0.5, 1)  # fraction of max for size
legend_radius <- sqrt(legend_values) * max_radius
legend_colors <- hazard_pal(legend_values * max(hazard_sites_full$Hazard_Index, na.rm = TRUE))

# Build custom HTML legend (color + size only, horizontal layout)
legend_html <- paste0(
  "<div style='line-height:1.5;background:white;padding:10px;border-radius:5px;
                      box-shadow:0 0 5px rgba(0,0,0,0.3);width:auto;'>",
  "<h4 style='margin:0;color:#4B0082;'>Hazard Index</h4>",
  "<div style='display:flex;align-items:center;justify-content:space-around;'>",
  paste0(
    sapply(seq_along(legend_values), function(i) {
      paste0(
        "<svg height='", max(legend_radius)*2, "' width='", max(legend_radius)*2, "' style='margin-right:5px;'>",
        "<circle cx='", max(legend_radius), "' cy='", max(legend_radius),
        "' r='", legend_radius[i], "' fill='", legend_colors[i],
        "' fill-opacity='0.7' stroke='black' stroke-width='0.5'/>",
        "</svg>"
      )
    }),
    collapse = ""
  ),
  "</div>",
  "</div>"
)

# Get bounding box of Michigan counties
mi_bounds <- st_bbox(mi_counties)

# Build interactive Leaflet map with custom zoom and bubble legend
leaflet(hazard_sites_full) %>%
  # Center on Michigan with zoomed-out view so full state fits
  setView(lng = -84.5, lat = 44.5, zoom = 6) %>%
  
  # Base map tiles
  addProviderTiles(providers$CartoDB.Positron) %>%
  
  # Michigan county polygons
  addPolygons(
    data = mi_counties,
    fillColor = "grey",
    color = "black",
    weight = 1,
    fillOpacity = 0.3,
    label = ~NAME
  ) %>%
  
  # Hazard site markers
  addCircleMarkers(
    radius = ~scaled_radius,  # proportional to Hazard_Index
    fillColor = ~hazard_pal(Hazard_Index),
    color = "black",
    fillOpacity = 0.7,
    stroke = TRUE,
    weight = 0.5,
    label = lapply(hazard_popup$popup, HTML),
    labelOptions = labelOptions(
      direction = "auto",
      textsize = "12px",
      opacity = 0.9,
      offset = c(0, -5)
    )
  ) %>%
  
  # Custom HTML bubble legend (color + size only)
  addControl(html = legend_html, position = "topright")

```


### Maps

#### Michigan PFAS Map

```{r}
#| eval: false
#| include: false

# Define main hazard analytes
hazard_analytes <- c("HFPODA", "PFNA", "PFBS", "PFHxS")

# Load Michigan counties shapefile
mi_counties <- st_read("GeoFiles/cb_2018_us_county_500k.shp", quiet = TRUE) %>%
  filter(STATEFP == "26") %>%
  st_transform(4326)   

# Prepare analyte-wide data
analyte_wide <- public_water_max_long %>%
  filter(analyte %in% hazard_analytes) %>%
  select(hex_id, analyte, analyte_value) %>%
  pivot_wider(
    names_from = analyte,
    values_from = analyte_value,
    values_fill = 0
  )

# Prepare hazard sites (sf)
hazard_sites_full <- public_water_max_long %>%
  filter(Hazard_Index > 1) %>%
  distinct(hex_id, system_name, system_type, Hazard_Index, longitude, latitude) %>%
  rename(type = system_type) %>%
  left_join(analyte_wide, by = "hex_id") %>%
  st_as_sf(coords = c("longitude", "latitude"), crs = 4326) %>%
  mutate(
    Hazard_Index = as.numeric(Hazard_Index),
    popup_label = paste0(
      "<b>System Name:</b> ", system_name, "<br>",
      "<b>Type:</b> ", type, "<br>",
      "<b>Hazard Index:</b> ", round(Hazard_Index, 2)
    )
  )

# Color palette + scaled radius
max_radius <- 20

hazard_pal <- colorNumeric(
  palette = "YlOrRd",
  domain = hazard_sites_full$Hazard_Index
)

hazard_sites_full <- hazard_sites_full %>%
  mutate(
    scaled_radius = sqrt(Hazard_Index / max(Hazard_Index, na.rm = TRUE)) * max_radius
  )

# Build searchable field (use system_name instead of type)
hazard_sites_full <- hazard_sites_full %>%
  mutate(
    search_field = system_name
  )

# SharedData for Crosstalk
shared_data <- SharedData$new(
  hazard_sites_full,
  key = ~hex_id,
  group = "hazard"
)

# FILTER WIDGET (Hazard Index)
filter_widget <- filter_slider(
  id = "hazard_filter",
  label = "Filter by Hazard Index",
  sharedData = shared_data,
  column = ~Hazard_Index,
  min = min(hazard_sites_full$Hazard_Index, na.rm = TRUE),
  max = max(hazard_sites_full$Hazard_Index, na.rm = TRUE),
  step = 0.1
)

# LEAFLET MAP
map_widget <- shared_data %>%
  leaflet() %>%
  setView(lng = -84.5, lat = 44.5, zoom = 6) %>%

  addProviderTiles(providers$CartoDB.Positron) %>%

  addPolygons(
    data = mi_counties,
    fillColor = "grey",
    color = "black",
    weight = 1,
    fillOpacity = 0.3
  ) %>%

  addCircleMarkers(
    radius = ~scaled_radius,
    fillColor = ~hazard_pal(Hazard_Index),
    color = "black",
    fillOpacity = 0.7,
    stroke = TRUE,
    weight = 0.5,
    popup = ~popup_label,
    label = ~lapply(popup_label, HTML),
    layerId = ~search_field,
    group = "HazardSites"
  ) %>%

  addLabelOnlyMarkers(
    lng = ~st_coordinates(geometry)[,1],
    lat = ~st_coordinates(geometry)[,2],
    label = ~round(Hazard_Index, 1),
    labelOptions = labelOptions(
      noHide = TRUE,
      textOnly = TRUE,
      style = list(
        "color" = "black",
        "font-size" = "10px",
        "font-weight" = "bold",
        "text-shadow" = "1px 1px 2px white"
      )
    )
  ) %>%

  addSearchFeatures(
    targetGroups = "HazardSites",
    options = searchFeaturesOptions(
      zoom = 11,
      openPopup = TRUE,
      firstTipSubmit = TRUE,
      autoCollapse = TRUE,
      hideMarkerOnCollapse = TRUE,
      propertyName = "layerId",
      textPlaceholder = "Search by system name..."
    )
  ) %>%

  addControl(
    html = htmltools::div(
      id = "filter-container",
      style = "background: rgba(255,255,255,0.85); padding: 10px; border-radius: 5px;",
      filter_widget
    ),
    position = "topright"
  ) %>%

  onRender("
    function(el, x) {
      var container = document.getElementById('filter-container');
      if (container) {
        L.DomEvent.disableScrollPropagation(container);
        L.DomEvent.disableClickPropagation(container);
      }
    }
  ")

map_widget


```

```{r}
#| label: hazard_bubble_map

# Define main hazard analytes
hazard_analytes <- c("HFPODA", "PFNA", "PFBS", "PFHxS")

# Load Michigan counties shapefile
mi_counties <- st_read("GeoFiles/cb_2018_us_county_500k.shp", quiet = TRUE) %>%
  filter(STATEFP == "26") %>%
  st_transform(4326)   

# Prepare analyte-wide data
analyte_wide <- public_water_max_long %>%
  filter(analyte %in% hazard_analytes) %>%
  select(hex_id, analyte, analyte_value) %>%
  pivot_wider(
    names_from = analyte,
    values_from = analyte_value,
    values_fill = 0
  )

# Prepare hazard sites (sf)
hazard_sites_full <- public_water_max_long %>%
  filter(Hazard_Index > 1) %>%
  distinct(hex_id, system_name, system_type, Hazard_Index, longitude, latitude) %>%
  rename(type = system_type) %>%
  left_join(analyte_wide, by = "hex_id") %>%
  mutate(system_name = str_to_title(str_remove(system_name, pattern = "[,] City Of"))) |> 
  replace_na(list(system_name = "Unknown",
                  type = "Unknown")) |> 
  st_as_sf(coords = c("longitude", "latitude"), crs = 4326) %>%
  mutate(
    Hazard_Index = as.numeric(Hazard_Index),
    popup_label = paste0(
      "<b>System Name:</b> ", system_name, "<br>",
      "<b>Type:</b> ", type, "<br>",
      "<b>Hazard Index:</b> ", sprintf("%.1f", Hazard_Index)
    )
  )

# Color palette + scaled radius
max_radius <- 20
desired_max <- 35

# Update scaled_radius calculation to use desired_max
hazard_sites_full <- hazard_sites_full %>%
  mutate(scaled_radius = sqrt(Hazard_Index / desired_max) * max_radius)

# Create legend data with extended range and scaled radius
legend_data <- tibble(
  Hazard_Index = seq(5, desired_max, by = 5)
) %>%
  mutate(scaled_radius = sqrt(Hazard_Index / desired_max) * max_radius)

hazard_pal <- colorNumeric(
  palette = c("#e5f5f9", "#99d8c9", "#2ca25f", "#006d2c"),
  domain = c(0, desired_max)
)

# Build searchable field
hazard_sites_full <- hazard_sites_full %>%
  mutate(search_field = system_name)

# SharedData for Crosstalk
shared_data <- SharedData$new(
  hazard_sites_full,
  key = ~hex_id,
  group = "hazard"
)

# LEAFLET MAP
map_widget <- hazard_sites_full %>%
  leaflet() %>%
  setView(lng = -84.5, lat = 44.5, zoom = 5.5) %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addPolygons(
    data = mi_counties,
    fillColor = "grey",
    color = "black",
    weight = 1,
    fillOpacity = 0.3
  ) %>%
  addCircleMarkers(
    lng = ~st_coordinates(geometry)[,1],
    lat = ~st_coordinates(geometry)[,2],
    radius = ~scaled_radius,
    color = ~hazard_pal(Hazard_Index),
    fillColor = ~hazard_pal(Hazard_Index), 
    fillOpacity = 0.7,
    opacity = 1,
    weight = 1,
    popup = ~popup_label,
    label = ~lapply(popup_label, htmltools::HTML)
  ) |>
  addLegendSize(
    values = legend_data$Hazard_Index,
    pal = hazard_pal, 
    title = 'Hazard Index',
    baseSize = max_radius / sqrt(desired_max / desired_max),  # Scaling factor
    shape = 'circle', 
    orientation = 'vertical',
    opacity = 1, 
    fillOpacity = 0.7, 
    position = 'bottomright',
    breaks = legend_data$Hazard_Index
  )

map_widget
```


### County Analysis
#### Top 15 Hazard > 1

```{r}
# JS for automatic bar hover
js_auto_hover <- "
function(el, x) {
  var totalPoints = el.data[0].y.length;
  var i = 0;
  setInterval(function() {
    Plotly.Fx.hover(el, [{ curveNumber: 0, pointNumber: i }], 'xy');
    i = (i + 1) % totalPoints;
  }, 2000);
}
"

# Define main hazard analytes
hazard_analytes <- c("HFPODA", "PFNA", "PFBS", "PFHxS")

# Aggregate analyte-level hazard contributions per county
county_analytes <- public_water_max_long %>%
  filter(
    Hazard_Index > 1,
    analyte %in% hazard_analytes,
    !is.na(analyte_value)
  ) %>%
  mutate(
    analyte_hazard = case_when(
      analyte == "HFPODA" ~ analyte_value / 10,
      analyte == "PFNA"   ~ analyte_value / 10,
      analyte == "PFBS"   ~ analyte_value / 2000,
      analyte == "PFHxS"  ~ analyte_value / 10
    )
  ) %>%
  group_by(geoid, analyte) %>%
  summarise(
    total_hazard_analyte = sum(analyte_hazard, na.rm = TRUE),
    n_sites = n_distinct(system_name),
    .groups = "drop"
  )

# Join county names and remove unknown counties
county_info <- st_read("GeoFiles/cb_2018_us_county_500k.shp", quiet = TRUE) %>%
  st_drop_geometry() %>%
  select(GEOID, NAME)

county_analytes <- county_analytes %>%
  left_join(county_info, by = c("geoid" = "GEOID")) %>%
  filter(!is.na(NAME))

# Compute total hazard per county to get top 15
county_total <- county_analytes %>%
  group_by(NAME) %>%
  summarise(
    total_hazard = sum(total_hazard_analyte, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  arrange(desc(total_hazard)) %>%
  slice_head(n = 15)

# Identify dominant analyte per county for tooltip
dominant_per_county <- county_analytes %>%
  filter(NAME %in% county_total$NAME) %>%
  group_by(NAME) %>%
  slice_max(total_hazard_analyte, n = 1, with_ties = FALSE) %>%
  ungroup() %>%
  select(NAME, dominant_analyte = analyte, dominant_hazard = total_hazard_analyte)

# Prepare plot data: top 15 counties only, ordered by total hazard
plot_data <- county_analytes %>%
  filter(NAME %in% county_total$NAME) %>%
  left_join(dominant_per_county, by = "NAME") %>%
  left_join(county_total, by = "NAME") %>%
  arrange(desc(total_hazard)) %>%
  mutate(NAME = factor(NAME, levels = unique(NAME)))  # enforce descending order

# Create Plotly stacked bar chart
p_overall <- plot_ly(
  data = plot_data,
  x = ~NAME,
  y = ~total_hazard_analyte,
  type = "bar",
  color = ~analyte,
  colors = viridis::cividis(length(hazard_analytes), end = 0.9),
  hoverinfo = "text",
  text = ~round(total_hazard_analyte, 2),
  textposition = "inside",
  hovertext = ~paste0(
    "<b>County:</b> ", NAME,
    "<br><b>Total Hazard Index:</b> ", round(total_hazard, 2),
    "<br><b>Dominant Analyte:</b> ", dominant_analyte,
    "<br><b>Contribution of Dominant Analyte:</b> ", round(dominant_hazard, 2),
    "<br><b>Number of Sites:</b> ", n_sites
  )
) %>%
  layout(
    title = "Top 15 Counties with Hazard Index >1",
    barmode = "stack",
    xaxis = list(title = "County", tickangle = -45),
    yaxis = list(title = "Hazard Index"),
    margin = list(b = 150),
    hoverlabel = list(
      bgcolor = "lightyellow",
      font = list(size = 12, color = "black"),
      bordercolor = "orange"
    )
  ) %>%
  onRender(js_auto_hover)

p_overall

```

```{r}
# JS for automatic bar hover
js_auto_hover <- "
function(el, x) {
  var totalPoints = el.data[0].y.length;
  var i = 0;
  setInterval(function() {
    Plotly.Fx.hover(el, [{ curveNumber: 0, pointNumber: i }], 'xy');
    i = (i + 1) % totalPoints;
  }, 2000);
}
"

# Define main hazard analytes
hazard_analytes <- c("HFPODA", "PFNA", "PFBS", "PFHxS")

# Aggregate analyte-level hazard contributions per county
county_analytes <- public_water_max_long %>%
  filter(
    Hazard_Index > 1,
    analyte %in% hazard_analytes,
    !is.na(analyte_value)
  ) %>%
  mutate(
    analyte_hazard = case_when(
      analyte == "HFPODA" ~ analyte_value / 10,
      analyte == "PFNA"   ~ analyte_value / 10,
      analyte == "PFBS"   ~ analyte_value / 2000,
      analyte == "PFHxS"  ~ analyte_value / 10
    )
  ) %>%
  group_by(geoid, analyte) %>%
  summarise(
    total_hazard_analyte = sum(analyte_hazard, na.rm = TRUE),
    n_sites = n_distinct(system_name),
    .groups = "drop"
  )

# Join county names
county_info <- st_read("GeoFiles/cb_2018_us_county_500k.shp", quiet = TRUE) %>%
  st_drop_geometry() %>%
  select(GEOID, NAME)

county_analytes <- county_analytes %>%
  left_join(county_info, by = c("geoid" = "GEOID")) %>%
  filter(!is.na(NAME))

# Compute total hazard per county to get top 15
county_total <- county_analytes %>%
  group_by(NAME) %>%
  summarise(
    total_hazard = sum(total_hazard_analyte, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  arrange(desc(total_hazard)) %>%
  slice_head(n = 15)

# Compute % contribution per analyte and prepare hover text
plot_data <- county_analytes %>%
  filter(NAME %in% county_total$NAME) %>%
  left_join(county_total, by = "NAME") %>%
  group_by(NAME) %>%
  mutate(
    percent_hazard = 100 * total_hazard_analyte / total_hazard
  ) %>%
  ungroup() %>%
  arrange(desc(total_hazard)) %>%
  mutate(NAME = factor(NAME, levels = unique(NAME)))

# Compute dominant analyte per county
dominant_per_county <- plot_data %>%
  group_by(NAME) %>%
  slice_max(total_hazard_analyte, n = 1, with_ties = FALSE) %>%
  ungroup() %>%
  select(NAME, dominant_analyte = analyte, dominant_hazard = total_hazard_analyte)

# Hover text per county: only non-zero analytes
hover_text_per_county <- plot_data %>%
  filter(percent_hazard > 0) %>%
  group_by(NAME) %>%
  summarise(
    hover_text = paste0(analyte, ": ", round(percent_hazard, 1), "%", collapse = "<br>"),
    .groups = "drop"
  )

# Join dominant analyte and hover text
plot_data <- plot_data %>%
  left_join(dominant_per_county, by = "NAME") %>%
  left_join(hover_text_per_county, by = "NAME")

# Create Plotly stacked bar chart
p_overall <- plot_ly(
  data = plot_data,
  x = ~NAME,
  y = ~percent_hazard,
  type = "bar",
  color = ~analyte,
  colors = viridis::cividis(length(hazard_analytes), end = 0.9),
  hoverinfo = "text",
  text = ~paste0(round(percent_hazard, 1), "%"),
  textposition = "inside",
  hovertext = ~hover_text  # only non-zero analytes
) %>%
  layout(
    title = "Top 15 Counties with Hazard Index > 1",
    barmode = "stack",
    xaxis = list(title = "County", tickangle = -45),
    yaxis = list(title = "Hazard Contribution (%)", range = c(0, 100)),
    margin = list(b = 150),
    hoverlabel = list(
      bgcolor = "lightyellow",
      font = list(size = 12, color = "black"),
      bordercolor = "orange"
    )
  ) %>%
  onRender(js_auto_hover)

p_overall
```

```{r}
# Prepare metrics table for top 15 counties
metrics_table <- plot_data %>%
  group_by(NAME) %>%
  summarise(
    `Dominant Analyte` = first(dominant_analyte),
    `Dominant Contribution` = first(dominant_hazard),
    `Total Hazard Index` = first(total_hazard),
    `Number of Sites` = sum(n_sites, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  rename(County = NAME) %>%
  arrange(desc(`Total Hazard Index`))

# Create reactable table
tbl_id <- "county_hazard_metrics_table"
rt <- reactable(
  metrics_table,
  elementId = tbl_id,
  columns = list(
    County = colDef(name = "COUNTY"),
    `Dominant Analyte` = colDef(name = "DOMINANT ANALYTE"),
    `Dominant Contribution` = colDef(name = "DOMINANT CONTRIBUTION"),
    `Total Hazard Index` = colDef(name = "TOTAL HAZARD INDEX"),
    `Number of Sites` = colDef(name = "NUMBER OF SITES")
  ),
  searchable = TRUE,
  filterable = TRUE,
  showPageSizeOptions = TRUE,
  defaultPageSize = 10,
  highlight = TRUE,
  bordered = TRUE,
  striped = TRUE
)

# Download button
download_btn <- tags$button(
  "Download CSV",
  onclick = sprintf("Reactable.downloadDataCSV('%s', 'county_hazard_metrics.csv')", tbl_id),
  style = "
    background: none;
    border: none;
    color: #0073e6;
    text-decoration: underline;
    cursor: pointer;
    font-size: 0.9em;
    float: right;
    margin-bottom: 5px;
  "
)

# Display table with download button
browsable(tagList(download_btn, rt))
```

```{r}
# Changing the system_type values to be more descriptive
public_water_max_long <- public_water_max_long |>
mutate(system_type = recode(system_type,
    "ADFSTC" = "Non-Community Water Supply (Adult Foster Care Provider)",
    "CHLCMP" = "Non-Community Water Supply (Children's Camp)",
    "DAYCARE" = "Non-Community Water Supply (Child Care Provider)",
    "INDUS" = "Non-Community Water Supply (Industry)",
    "MEDCAR" = "Non-Community Water Supply (Medical Care Provider)",
    "MOTEL" = "Non-Community Water Supply (Hotel or Motel)",
    "MUN" = "Community Water Supply (for example Municipal Supply, Apartment, Nursing Home, Prison, etc.)",
    "OFFICE" = "Office Building",
    "PARK" = "Park",
    "RESD" = "Residential",
    "SCH" = "School",
    "TRB" = "Tribal Lands"
  ))
```

### Sampled Systems
#### Hazard Index per System
```{r}
# Define main hazard analytes
hazard_analytes <- c("HFPODA", "PFNA", "PFBS", "PFHxS")

# Aggregate analyte-level hazard contributions by system
system_analytes <- public_water_max_long |>
  filter(
    Hazard_Index > 1,
    !is.na(analyte),
    analyte %in% hazard_analytes,
    !is.na(analyte_value),
    !is.na(system_name)
  ) |>
  mutate(
    system_name = tolower(system_name),
    analyte_hazard = case_when(
      analyte == "HFPODA" ~ analyte_value / 10,
      analyte == "PFNA"   ~ analyte_value / 10,
      analyte == "PFBS"   ~ analyte_value / 2000,
      analyte == "PFHxS"  ~ analyte_value / 10
    )
  ) |>
  group_by(system_name, analyte) |>
  summarise(
    total_hazard_analyte = sum(analyte_hazard, na.rm = TRUE),
    .groups = "drop"
  )

# Compute total hazard per system to identify top systems
system_total <- system_analytes |>
  group_by(system_name) |>
  summarise(
    total_hazard = sum(total_hazard_analyte, na.rm = TRUE),
    .groups = "drop"
  ) |>
  arrange(desc(total_hazard)) |>
  slice_head(n = 10)

# Filter analytes to top systems
system_analytes_top <- system_analytes |>
  filter(system_name %in% system_total$system_name) |>
  mutate(
    system_name = factor(system_name, levels = system_total$system_name)
  )

# Identify dominant analyte per system
dominant_per_system <- system_analytes_top |>
  group_by(system_name) |>
  slice_max(order_by = total_hazard_analyte, n = 1, with_ties = FALSE) |>
  ungroup() |>
  rename(dominant_analyte = analyte,
         dominant_hazard = total_hazard_analyte) |>
  select(system_name, dominant_analyte, dominant_hazard)

# Merge dominant info back for tooltip
system_analytes_top <- system_analytes_top |>
  left_join(dominant_per_system, by = "system_name")

# Create stacked hazard index contribution plot with tooltip showing only dominant analyte
p_system_hazard <- ggplot(
  system_analytes_top,
  aes(
    x = system_name,
    y = total_hazard_analyte,
    fill = analyte,
    text = paste(
      "<b>System:</b>", system_name,
      "<br><b>Dominant Analyte:</b>", dominant_analyte,
      "<br><b>Contribution:</b>", round(dominant_hazard, 2)
    )
  )
) +
  geom_col(width = 0.7, position = "stack") +
  scale_fill_viridis_d(option = "cividis", end = 0.9) +
  labs(
    title = "Hazard Index Decomposition for Top Systems",
    x = "System Name",
    y = "Hazard Index",
    fill = "Analyte",
    caption = "Data source: Michigan PFAS Action Response Team (MPART)"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.position = "right"
  )

# Convert to interactive Plotly chart with automatic hover
ggplotly(p_system_hazard, tooltip = "text") |>
  onRender(js_auto_hover) |>
  layout(
    hoverlabel = list(
      bgcolor = "lightyellow",
      font = list(color = "black", size = 12),
      bordercolor = "orange"
    )
  )

```
```{r}
# Prepare metrics table for top systems

# Define main hazard analytes
hazard_analytes <- c("HFPODA", "PFNA", "PFBS", "PFHxS")

# Aggregate analyte-level hazard contributions per system
system_analytes <- public_water_max_long |>
  filter(
    Hazard_Index > 1,
    !is.na(analyte),
    analyte %in% hazard_analytes,
    !is.na(analyte_value),
    !is.na(system_name)
  ) |>
  mutate(
    analyte_hazard = case_when(
      analyte == "HFPODA" ~ analyte_value / 10,
      analyte == "PFNA"   ~ analyte_value / 10,
      analyte == "PFBS"   ~ analyte_value / 2000,
      analyte == "PFHxS"  ~ analyte_value / 10
    )
  ) |>
  group_by(system_name, analyte) |>
  summarise(
    total_hazard_analyte = sum(analyte_hazard, na.rm = TRUE),
    n_sites = n_distinct(hex_id),
    .groups = "drop"
  )

# Compute total hazard per system to identify top systems
system_total <- system_analytes |>
  group_by(system_name) |>
  summarise(
    total_hazard = sum(total_hazard_analyte, na.rm = TRUE),
    .groups = "drop"
  ) |>
  arrange(desc(total_hazard)) |>
  slice_head(n = 10)

# Identify dominant analyte per system
dominant_per_system <- system_analytes |>
  filter(system_name %in% system_total$system_name) |>
  group_by(system_name) |>
  slice_max(order_by = total_hazard_analyte, n = 1, with_ties = FALSE) |>
  ungroup() |>
  rename(
    `Dominant Analyte` = analyte,
    `Dominant Contribution` = total_hazard_analyte
  ) |>
  select(system_name, `Dominant Analyte`, `Dominant Contribution`)

# Prepare metrics table
metrics_table <- system_total |>
  filter(system_name %in% system_total$system_name) |>
  left_join(dominant_per_system, by = "system_name") |>
  left_join(
    system_analytes |>
      pivot_wider(
        names_from = analyte,
        values_from = total_hazard_analyte,
        values_fill = 0
      ) |>
      select(system_name, all_of(hazard_analytes)),
    by = "system_name"
  ) |>
  rename(System = system_name, `Total Hazard Index` = total_hazard) |>
  arrange(desc(`Total Hazard Index`))

# -------------------------------
# Render interactive table using reactable
tbl_id <- "system_hazard_metrics_table"

rt <- reactable(
  metrics_table,
  elementId = tbl_id,
  columns = list(
    System = colDef(name = "SYSTEM"),
    `Dominant Analyte` = colDef(name = "DOMINANT ANALYTE"),
    `Dominant Contribution` = colDef(name = "DOMINANT CONTRIBUTION"),
    `Total Hazard Index` = colDef(name = "TOTAL HAZARD INDEX"),
    HFPODA = colDef(name = "HFPODA"),
    PFNA = colDef(name = "PFNA"),
    PFBS = colDef(name = "PFBS"),
    PFHxS = colDef(name = "PFHxS")
  ),
  searchable = TRUE,
  filterable = TRUE,
  showPageSizeOptions = TRUE,
  defaultPageSize = 10,
  highlight = TRUE,
  bordered = TRUE,
  striped = TRUE
)

# Download button
download_btn <- tags$button(
  "Download CSV",
  onclick = sprintf("Reactable.downloadDataCSV('%s', 'system_hazard_metrics.csv')", tbl_id),
  style = "
    background: none;
    border: none;
    color: #0073e6;
    text-decoration: underline;
    cursor: pointer;
    font-size: 0.9em;
    float: right;
    margin-bottom: 5px;
  "
)

# Display table with download button
browsable(tagList(download_btn, rt))

```

### System Types
#### System Type Composition and decomposed contribution

```{r}
# Aggregate hazard contributions by system type
system_analytes_top <- public_water_max_long |>
  filter(
    Hazard_Index > 1,
    !is.na(analyte),
    analyte %in% hazard_analytes,
    !is.na(system_short)
  ) |>
  mutate(
    analyte_hazard = case_when(
      analyte == "HFPODA" ~ analyte_value / 10,
      analyte == "PFNA"   ~ analyte_value / 10,
      analyte == "PFBS"   ~ analyte_value / 2000,
      analyte == "PFHxS"  ~ analyte_value / 10
    )
  ) |>
  group_by(system_short, analyte) |>
  summarise(
    total_hazard_analyte = sum(analyte_hazard, na.rm = TRUE),
    .groups = "drop"
  )

# Compute total hazard per system_short (ALL system types)
system_total <- system_analytes_top |>
  group_by(system_short) |>
  summarise(total_hazard = sum(total_hazard_analyte, na.rm = TRUE), .groups = "drop") |>
  arrange(desc(total_hazard))

# Keep ALL system types (no filtering)
system_analytes_top <- system_analytes_top |>
  mutate(system_short = factor(system_short, levels = system_total$system_short))

# Compute dominant analyte per system_short
dominant_per_system <- system_analytes_top |>
  group_by(system_short) |>
  slice_max(order_by = total_hazard_analyte, n = 1, with_ties = FALSE) |>
  ungroup() |>
  rename(
    dominant_analyte = analyte,
    dominant_hazard = total_hazard_analyte
  ) |>
  select(system_short, dominant_analyte, dominant_hazard)

# Merge dominant info back
system_analytes_top <- system_analytes_top |>
  left_join(dominant_per_system, by = "system_short")

# Plot ALL system types
p_system_hazard <- ggplot(
  system_analytes_top,
  aes(
    x = system_short,
    y = total_hazard_analyte,
    fill = analyte,
    text = paste("<br><b>System Type:</b>", system_short,
      "<br><b>Dominant Analyte:</b>", dominant_analyte,
      "<br><b>Contribution:</b>", round(dominant_hazard, 2)
    )
  )
) +
  geom_col(width = 0.7, position = "stack") +
  scale_fill_viridis_d(option = "cividis", end = 0.9) +
  labs(
    title = "Hazard Index Decomposition by System Type",
    x = "System Type",
    y = "Hazard Index",
    fill = "Analyte"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.position = "right"
  )

ggplotly(p_system_hazard, tooltip = "text") |>
  onRender(js_auto_hover)


```


```{r}
# Step 1â€“5: Prepare the system hazard summary table
system_analytes_top <- public_water_max_long %>%
  filter(
    Hazard_Index > 1,
    !is.na(analyte),
    analyte %in% hazard_analytes,
    !is.na(system_short)
  ) %>%
  mutate(
    analyte_hazard = case_when(
      analyte == "HFPODA" ~ analyte_value / 10,
      analyte == "PFNA"   ~ analyte_value / 10,
      analyte == "PFBS"   ~ analyte_value / 2000,
      analyte == "PFHxS"  ~ analyte_value / 10
    )
  ) %>%
  group_by(system_short, analyte) %>%
  summarise(total_hazard_analyte = sum(analyte_hazard, na.rm = TRUE), .groups = "drop")

system_total <- system_analytes_top %>%
  group_by(system_short) %>%
  summarise(total_hazard = sum(total_hazard_analyte, na.rm = TRUE), .groups = "drop") %>%
  arrange(desc(total_hazard)) %>%
  slice_head(n = 15)

system_analytes_top <- system_analytes_top %>%
  filter(system_short %in% system_total$system_short)

dominant_per_system <- system_analytes_top %>%
  group_by(system_short) %>%
  slice_max(order_by = total_hazard_analyte, n = 1, with_ties = FALSE) %>%
  ungroup() %>%
  rename(
    dominant_analyte = analyte,
    dominant_hazard = total_hazard_analyte
  ) %>%
  select(system_short, dominant_analyte, dominant_hazard)

system_hazard_agg <- system_total %>%
  left_join(dominant_per_system, by = "system_short") %>%
  left_join(system_type_map %>% select(short_name, full_name),
            by = c("system_short" = "short_name")) %>%
  mutate(across(where(is.numeric), ~ round(.x, 2))) %>%
  arrange(desc(total_hazard))

# Step 6: Create reactable table only (no plot)
tbl_id <- "system_summary_table"

rt_system_summary <- reactable(
  system_hazard_agg,
  elementId = tbl_id,
  searchable = TRUE,
  filterable = TRUE,
  showPageSizeOptions = TRUE,
  defaultPageSize = 10,
  highlight = TRUE,
  bordered = TRUE,
  striped = TRUE,
  columns = list(
    full_name = colDef(name = "FULL DESCRIPTIVE NAME"),
    system_short = colDef(name = "SHORT NAME"),
    total_hazard = colDef(name = "TOTAL HAZARD"),
    dominant_analyte = colDef(name = "DOMINANT ANALYTE"),
    dominant_hazard = colDef(name = "DOMINANT HAZARD")
  )
)

# Step 7: Download button
download_btn <- tags$button(
  "Download CSV",
  onclick = sprintf("Reactable.downloadDataCSV('%s', 'system_summary.csv')", tbl_id),
  style = "
    background: none;
    border: none;
    color: #0073e6;
    text-decoration: underline;
    cursor: pointer;
    font-size: 0.9em;
    float: right;
    margin-bottom: 5px;
  "
)

# Display the table with download button
browsable(tagList(download_btn, rt_system_summary))

```
### Systems' Map
#### Map showing the locations of different system types
```{r}
# Extract system locations from public_water_max_long
system_locations <- public_water_max_long |>
  filter(
    Hazard_Index > 1,
    !is.na(system_short)
  ) |>
  distinct(
    hex_id, system_name, system_short,
    Hazard_Index, longitude, latitude
  )

# Add dominant analyte info
system_locations <- system_locations |>
  left_join(dominant_per_system, by = "system_short") |>
  mutate(
    popup_label = paste0(
      "<b>System Name:</b> ", system_name, "<br>",
      "<b>System Type:</b> ", system_short, "<br>",
      "<b>Hazard Index:</b> ", round(Hazard_Index, 2), "<br>",
      "<b>Dominant Analyte:</b> ", dominant_analyte, "<br>",
      "<b>Contribution:</b> ", round(dominant_hazard, 2)
    )
  )

# Crosstalk SharedData
sd_systems <- SharedData$new(system_locations, key = ~hex_id, group = "systems")

# Load Michigan counties
mi_counties <- st_read("GeoFiles/cb_2018_us_county_500k.shp", quiet = TRUE) |>
  filter(STATEFP == "26") |>
  st_transform(4326)

# Color palette for ALL system types
pal_sys <- colorFactor("viridis", system_locations$system_short)

# Crosstalk filter UI
filter_ui <- filter_select(
  id = "system_filter",
  label = "Filter by System Type",
  sharedData = sd_systems,
  group = ~system_short
)

# Build the map (reactive to Crosstalk)
map_widget <- leaflet(sd_systems) %>%
  setView(lng = -84.5, lat = 44.5, zoom = 6) %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addPolygons(
    data = mi_counties,
    fillColor = "grey",
    color = "black",
    weight = 1,
    fillOpacity = 0.3
  ) %>%
  addCircleMarkers(
    lng = ~longitude,
    lat = ~latitude,
    radius = ~sqrt(Hazard_Index) * 2,
    fillColor = ~pal_sys(system_short),
    color = "black",
    fillOpacity = 0.8,
    stroke = TRUE,
    weight = 0.5,
    popup = ~popup_label,
    label = ~lapply(popup_label, htmltools::HTML)
  ) %>%
  addLegend(
    pal = pal_sys,
    values = system_locations$system_short,
    title = "System Type",
    position = "topright"
  )

# Display filter ABOVE the map (best for dashboards)
tagList(
  div(style = "margin-bottom: 10px;", filter_ui),
  div(style = "width: 100%;", map_widget)
)

```

```{r}
# Build metrics table from system_locations
metrics_table <- system_locations |>
  group_by(system_short) |>
  summarise(
    n_systems = n(),                                 # number of systems of this type
    mean_hazard = mean(Hazard_Index, na.rm = TRUE),  # average hazard
    total_hazard = sum(Hazard_Index, na.rm = TRUE),  # total hazard
    dominant_analyte = first(dominant_analyte),      # from your join
    dominant_hazard = first(dominant_hazard),        # from your join
    .groups = "drop"
  ) |>
  # Join full descriptive name
  left_join(
    system_type_map %>% select(short_name, full_name),
    by = c("system_short" = "short_name")
  ) |>
  arrange(desc(n_systems)) |>
  mutate(
    mean_hazard = round(mean_hazard, 2),
    total_hazard = round(total_hazard, 2),
    dominant_hazard = round(dominant_hazard, 2)
  )

# Assign table ID for download
tbl_id <- "system_metrics_table"

# Build reactable
rt_system_metrics <- reactable(
  metrics_table,
  elementId = tbl_id,
  searchable = TRUE,
  filterable = TRUE,
  highlight = TRUE,
  bordered = TRUE,
  striped = TRUE,
  defaultPageSize = 10,
  columns = list(
    full_name = colDef(name = "Full Descriptive Name"),
    system_short = colDef(name = "Short Name"),
    n_systems = colDef(name = "Number of Systems"),
    mean_hazard = colDef(name = "Mean Hazard Index"),
    total_hazard = colDef(name = "Total Hazard Index"),
    dominant_analyte = colDef(name = "Dominant Analyte"),
    dominant_hazard = colDef(name = "Dominant Analyte Contribution")
  )
)

# Download button
download_btn <- tags$button(
  "Download CSV",
  onclick = sprintf("Reactable.downloadDataCSV('%s', 'system_metrics_table.csv')", tbl_id),
  style = "
    background: none;
    border: none;
    color: #0073e6;
    text-decoration: underline;
    cursor: pointer;
    font-size: 0.9em;
    float: right;
    margin-bottom: 5px;
  "
)

# Display table with download button
browsable(tagList(download_btn, rt_system_metrics))


```

### Site Type Analysis
#### Mean Hazard Index per Site
```{r, include=FALSE}
hazard_data_types <- merged_data |>
  mutate(
    type = str_replace_all(type, "mlitary", "military"),
    type = str_to_title(type),
    type = str_replace_all(type, "Laundromat/Drycleaner", "Laundromat/Dry Cleaner"),
    type = case_when(type %in% c("Tannery", "Unknown", 
                                 "Refinery", "Fire Station") ~ "Other",
                     TRUE ~ type)
  ) |>
  filter(Hazard_Index > 1, !is.na(type)) |>
  distinct(hex_id, type, Hazard_Index)

mean_by_type <- hazard_data_types |>
  group_by(type) |>
  summarise(
    mean_hazard = mean(Hazard_Index, na.rm = TRUE),
    n_sites = n(),
    .groups = "drop"
  )

top_types <- mean_by_type |>
  arrange(desc(mean_hazard)) |>
  slice_head(n = 15)

plot_data <- mean_by_type |>
  filter(type %in% top_types$type) |>
  mutate(type = factor(type, levels = top_types$type))

p <- ggplot(plot_data, aes(
  x = type, 
  y = mean_hazard, 
  fill = type,
  text = paste("<br><b>Site Type:</b>", type,
               "<br><b>Mean Hazard Index:</b>", round(mean_hazard, 2),
               "<br><b>Number of Sites:</b>", n_sites)
)) +
  geom_col(position = position_dodge(width = 0.7), width = 0.7) +
  scale_fill_viridis_d(option = "cividis") +
  labs(
    title = "Mean Hazard Index by Site Type (Hazard_Index > 1)",
    x = "Site Type",
    y = "Mean Hazard Index (ppt)",
    fill = "Site Type",
    caption = "Data source: Michigan PFAS Action Response Team (MPART)"
  ) +
  theme_minimal() +
  theme(
    legend.position = "none",
    axis.text.x = element_text(angle = 45, hjust = 1)
  )

ggplotly(p, tooltip = "text") |>
  onRender("
    function(el) {
      var totalPoints = el.data[0].x.length;
      var i = 0;
      setInterval(function() {
        Plotly.Fx.hover(el, [{ curveNumber: 0, pointNumber: i }], 'xy');
        i = (i + 1) % totalPoints;
      }, 2000);
    }
  ")

```

```{r}
# Convert pfas_sites to sf and clean type
pfas_sites_sf <- pfas_sites %>%
  mutate(
    type = str_replace_all(type, "mlitary", "military"),
    type = str_to_title(type),
    type = str_replace_all(type, "Laundromat/Drycleaner", "Laundromat/Dry Cleaner"),
    type = case_when(
      type %in% c("Tannery", "Unknown", "Refinery", "Fire Station") ~ "Other",
      TRUE ~ type
    ),
    popup_label = paste0(
      "<b>Facility:</b> ", facility, "<br>",
      "<b>Type:</b> ", type, "<br>",
      "<b>County:</b> ", county
    )
  )

# Crosstalk SharedData
sd_sites <- SharedData$new(pfas_sites_sf, key = ~facility, group = "pfas")

# Load Michigan counties shapefile
mi_counties <- st_read("GeoFiles/cb_2018_us_county_500k.shp", quiet = TRUE) %>%
  filter(STATEFP == "26") %>%
  st_transform(4326)

# Viridis palette
pal <- colorFactor("viridis", pfas_sites_sf$type)

# Crosstalk filter UI (placed ABOVE map)
filter_ui <- filter_select(
  id = "type_filter",
  label = "Search by Site Type",
  sharedData = sd_sites,
  group = ~type
)

# Leaflet map (full width)
map <- leaflet(sd_sites) %>%
  setView(lng = -84.5, lat = 44.5, zoom = 5.5) %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addPolygons(
    data = mi_counties,
    fillColor = "grey",
    color = "black",
    weight = 1,
    fillOpacity = 0.3
  ) %>%
  addCircleMarkers(
    lng = ~longitude, lat = ~latitude,
    radius = 4,
    fillColor = ~pal(type),
    stroke = FALSE,
    fillOpacity = 0.8,
    popup = ~popup_label,
    label = ~lapply(popup_label, htmltools::HTML)
  ) %>%
  addLegendFactor(
    pal = pal,
    values = pfas_sites_sf$type,
    title = "Contamination Site Type",
    position = "topright",
    shape = "circle",
    width = 8,
    height = 8,
    fillOpacity = 0.8
  )

# Display filter ABOVE map (full width)
tagList(
  div(style = "margin-bottom: 10px;", filter_ui),
  div(style = "width: 100%;", map)
)

```

```{r}
# Visualizing the type of site by the composition of 4 main analytes with the hazard index

# Use the already-cleaned hazard_data_types to get clean type values
# Join back to merged_data to restore analyte columns
hazard_data_analytes <- merged_data |>
  inner_join(
    hazard_data_types |> select(hex_id, type, Hazard_Index),
    by = c("hex_id", "type", "Hazard_Index")
  ) |>
  distinct(hex_id, type, analyte, analyte_value, Hazard_Index) |>
  filter(analyte %in% hazard_analytes)

# Summarize total hazard and analyte sums by type
hazard_summary_by_type <- hazard_data_analytes |>
  group_by(type, analyte) |>
  summarise(sum_analyte = sum(analyte_value, na.rm = TRUE), .groups = "drop") |>
  left_join(
    hazard_data_analytes |>
      group_by(type) |>
      summarise(
        total_hazard = sum(Hazard_Index, na.rm = TRUE),
        n_sites = n_distinct(hex_id),
        .groups = "drop"
      ),
    by = "type"
  ) |>
  pivot_wider(
    names_from = analyte,
    values_from = sum_analyte,
    values_fill = 0
  ) |>
  mutate(across(where(is.numeric), ~ round(.x, 2))) |>
  arrange(desc(total_hazard))

# Assign a unique ID for reactable
tbl_id <- "hazard_summary_table"

# Create the interactive table with custom headers
rt <- reactable(
  hazard_summary_by_type,
  elementId = tbl_id,
  searchable = TRUE,
  filterable = TRUE,
  showPageSizeOptions = TRUE,
  defaultPageSize = 10,
  highlight = TRUE,
  bordered = TRUE,
  striped = TRUE,
  columns = list(
    type = colDef(name = "TYPE"),
    total_hazard = colDef(name = "TOTAL HAZARD"),
    n_sites = colDef(name = "N SITES")
  )
)

# Create download link-style button in top-right
download_btn <- tags$button(
  "Download CSV",
  onclick = sprintf("Reactable.downloadDataCSV('%s', 'hazard_summary_by_type.csv')", tbl_id),
  style = "
    background: none;
    border: none;
    color: #0073e6;
    text-decoration: underline;
    cursor: pointer;
    font-size: 0.9em;
    float: right;
    margin-bottom: 5px;
  "
)

# Display table with download link above it
browsable(tagList(download_btn, rt))


```

